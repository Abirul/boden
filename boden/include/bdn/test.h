/*  This file is based on the Catch test framework. It has been adapted to
 *  use existing boden parts where possible.
 *
 *  This single file is distributed under a license that is separate
 *  from the rest of the library.
 *  It is distributed under the Boost Software License, Version 1.0 (see below)
 *
 *  Modifications Copyright (c) Ashampoo Systems GmbH & Co. KG
 *  Original version from Catch Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.

 Boost Software License - Version 1.0 - August 17th, 2003

 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so, all subject to the following:

 The copyright notices in the Software and this entire statement, including
 the above license grant, this restriction and the following disclaimer,
 must be included in all copies of the Software, in whole or in part, and
 all derivative works of the Software, unless such copies or derivative
 works are solely in the form of machine-executable object code generated by
 a source language processor.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.

 */
#ifndef _BDN_test_H_
#define _BDN_test_H_

#include <type_traits>

#include <bdn/IUnhandledProblem.h>


#define TWOBLUECUBES_BDN_HPP_INCLUDED

#ifdef __clang__
#    pragma clang system_header
#elif defined __GNUC__
#    pragma GCC system_header
#endif

// #included from: internal/catch_suppress_warnings.h

#ifdef __clang__
#   ifdef __ICC // icpc defines the __clang__ macro
#       pragma warning(push)
#       pragma warning(disable: 161 1682)
#   else // __ICC
#       pragma clang diagnostic ignored "-Wglobal-constructors"
#       pragma clang diagnostic ignored "-Wvariadic-macros"
#       pragma clang diagnostic ignored "-Wc99-extensions"
#       pragma clang diagnostic ignored "-Wunused-variable"
#       pragma clang diagnostic push
#       pragma clang diagnostic ignored "-Wpadded"
#       pragma clang diagnostic ignored "-Wc++98-compat"
#       pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#       pragma clang diagnostic ignored "-Wswitch-enum"
#       pragma clang diagnostic ignored "-Wcovered-switch-default"
#    endif
#elif defined __GNUC__
#    pragma GCC diagnostic ignored "-Wvariadic-macros"
#    pragma GCC diagnostic ignored "-Wunused-variable"
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wpadded"
#endif
#if defined(BDN_CONFIG_MAIN) || defined(BDN_CONFIG_RUNNER)
#  define BDN_IMPL
#endif


// #included from: internal/catch_notimplemented_exception.h
#define TWOBLUECUBES_BDN_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED

// #included from: catch_common.h
#define TWOBLUECUBES_BDN_COMMON_H_INCLUDED

#define INTERNAL_BDN_UNIQUE_NAME_LINE2( name, line ) name##line
#define INTERNAL_BDN_UNIQUE_NAME_LINE( name, line ) INTERNAL_BDN_UNIQUE_NAME_LINE2( name, line )
#define INTERNAL_BDN_UNIQUE_NAME( name ) INTERNAL_BDN_UNIQUE_NAME_LINE( name, __LINE__ )


#define INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER_LINE2( name, line, counter ) name##_##line##_##counter
#define INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER_LINE( name, line, counter ) INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER_LINE2( name, line, counter )

#ifdef __COUNTER__
#define INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( name ) INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER_LINE( name, __LINE__, __COUNTER__ )
#else
#define INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( name ) INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER_LINE( name, __LINE__, 0 )
#endif



#define INTERNAL_BDN_STRINGIFY2( expr ) #expr
#define INTERNAL_BDN_STRINGIFY( expr ) INTERNAL_BDN_STRINGIFY2( expr )

#include <sstream>
#include <stdexcept>
#include <algorithm>
#include <list>

#include <bdn/Size.h>
#include <bdn/Rect.h>
#include <bdn/Margin.h>
#include <bdn/UiLength.h>
#include <bdn/UiMargin.h>
#include <bdn/UiSize.h>
#include <bdn/Thread.h>
#include <bdn/property.h>
#include <bdn/ProgrammingError.h>
#include <bdn/ExpectProgrammingError.h>

// #included from: catch_compiler_capabilities.h
#define TWOBLUECUBES_BDN_COMPILER_CAPABILITIES_HPP_INCLUDED

// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
// The following features are defined:
//
// BDN_CONFIG_CPP11_NULLPTR : is nullptr supported?
// BDN_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
// BDN_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
// BDN_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?
// BDN_CONFIG_CPP11_TUPLE : std::tuple is supported
// BDN_CONFIG_CPP11_LONG_LONG : is long long supported?
// BDN_CONFIG_CPP11_OVERRIDE : is override supported?
// BDN_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)

// BDN_CONFIG_CPP11_OR_GREATER : Is C++11 supported?

// BDN_CONFIG_VARIADIC_MACROS : are variadic macros supported?

// ****************
// Note to maintainers: if new toggles are added please document them
// in configuration.md, too
// ****************

// In general each macro has a _NO_<feature name> form
// (e.g. BDN_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
// Many features, at point of detection, define an _INTERNAL_ macro, so they
// can be combined, en-mass, with the _NO_ forms later.

// All the C++11 features can be disabled with BDN_CONFIG_NO_CPP11

#ifdef __clang__

#  if __has_feature(cxx_nullptr)
#    define BDN_INTERNAL_CONFIG_CPP11_NULLPTR
#  endif

#  if __has_feature(cxx_noexcept)
#    define BDN_INTERNAL_CONFIG_CPP11_NOEXCEPT
#  endif

#endif // __clang__

////////////////////////////////////////////////////////////////////////////////
// Borland
#ifdef __BORLANDC__

#endif // __BORLANDC__

////////////////////////////////////////////////////////////////////////////////
// EDG
#ifdef __EDG_VERSION__

#endif // __EDG_VERSION__

////////////////////////////////////////////////////////////////////////////////
// Digital Mars
#ifdef __DMC__

#endif // __DMC__

////////////////////////////////////////////////////////////////////////////////
// GCC
#ifdef __GNUC__

#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#   define BDN_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

// - otherwise more recent versions define __cplusplus >= 201103L
// and will get picked up below

#endif // __GNUC__

////////////////////////////////////////////////////////////////////////////////
// Visual C++
#ifdef _MSC_VER

#if (_MSC_VER >= 1600)
#   define BDN_INTERNAL_CONFIG_CPP11_NULLPTR
#   define BDN_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
#define BDN_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define BDN_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#endif // _MSC_VER

////////////////////////////////////////////////////////////////////////////////

// Use variadic macros if the compiler supports them
#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \
    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \
    ( defined __GNUC__ && __GNUC__ >= 3 ) || \
    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )

#define BDN_INTERNAL_CONFIG_VARIADIC_MACROS

#endif

////////////////////////////////////////////////////////////////////////////////
// C++ language feature support

// catch all support for C++11


#if defined(__cplusplus) && (__cplusplus >= 201103L || defined(__cplusplus_cli) )

#  define BDN_CPP11_OR_GREATER

#  if !defined(BDN_INTERNAL_CONFIG_CPP11_NULLPTR)
#    define BDN_INTERNAL_CONFIG_CPP11_NULLPTR
#  endif

#  ifndef BDN_INTERNAL_CONFIG_CPP11_NOEXCEPT
#    define BDN_INTERNAL_CONFIG_CPP11_NOEXCEPT
#  endif

#  ifndef BDN_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#    define BDN_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#  endif

#  ifndef BDN_INTERNAL_CONFIG_CPP11_IS_ENUM
#    define BDN_INTERNAL_CONFIG_CPP11_IS_ENUM
#  endif

#  ifndef BDN_INTERNAL_CONFIG_CPP11_TUPLE
#    define BDN_INTERNAL_CONFIG_CPP11_TUPLE
#  endif

#  ifndef BDN_INTERNAL_CONFIG_VARIADIC_MACROS
#    define BDN_INTERNAL_CONFIG_VARIADIC_MACROS
#  endif

#  if !defined(BDN_INTERNAL_CONFIG_CPP11_LONG_LONG)
#    define BDN_INTERNAL_CONFIG_CPP11_LONG_LONG
#  endif

#  if !defined(BDN_INTERNAL_CONFIG_CPP11_OVERRIDE)
#    define BDN_INTERNAL_CONFIG_CPP11_OVERRIDE
#  endif
#  if !defined(BDN_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
#    define BDN_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#  endif

#endif // __cplusplus >= 201103L

// Now set the actual defines based on the above + anything the user has configured
#if defined(BDN_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(BDN_CONFIG_CPP11_NO_NULLPTR) && !defined(BDN_CONFIG_CPP11_NULLPTR) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_NULLPTR
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(BDN_CONFIG_CPP11_NO_NOEXCEPT) && !defined(BDN_CONFIG_CPP11_NOEXCEPT) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_NOEXCEPT
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(BDN_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(BDN_CONFIG_CPP11_GENERATED_METHODS) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_GENERATED_METHODS
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(BDN_CONFIG_CPP11_NO_IS_ENUM) && !defined(BDN_CONFIG_CPP11_IS_ENUM) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_IS_ENUM
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(BDN_CONFIG_CPP11_NO_TUPLE) && !defined(BDN_CONFIG_CPP11_TUPLE) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_TUPLE
#endif
#if defined(BDN_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(BDN_CONFIG_NO_VARIADIC_MACROS) && !defined(BDN_CONFIG_VARIADIC_MACROS)
#   define BDN_CONFIG_VARIADIC_MACROS
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(BDN_CONFIG_NO_LONG_LONG) && !defined(BDN_CONFIG_CPP11_LONG_LONG) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_LONG_LONG
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(BDN_CONFIG_NO_OVERRIDE) && !defined(BDN_CONFIG_CPP11_OVERRIDE) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_OVERRIDE
#endif
#if defined(BDN_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(BDN_CONFIG_NO_UNIQUE_PTR) && !defined(BDN_CONFIG_CPP11_UNIQUE_PTR) && !defined(BDN_CONFIG_NO_CPP11)
#   define BDN_CONFIG_CPP11_UNIQUE_PTR
#endif

// noexcept support:
#if defined(BDN_CONFIG_CPP11_NOEXCEPT) && !defined(BDN_NOEXCEPT)
#  define BDN_NOEXCEPT noexcept
#  define BDN_NOEXCEPT_IS(x) noexcept(x)
#else
#  define BDN_NOEXCEPT throw()
#  define BDN_NOEXCEPT_IS(x)
#endif

// nullptr support
#ifdef BDN_CONFIG_CPP11_NULLPTR
#   define BDN_NULL nullptr
#else
#   define BDN_NULL NULL
#endif

// override support
#ifdef BDN_CONFIG_CPP11_OVERRIDE
#   define BDN_OVERRIDE override
#else
#   define BDN_OVERRIDE
#endif

// unique_ptr support
#ifdef BDN_CONFIG_CPP11_UNIQUE_PTR
#   define BDN_AUTO_PTR( T ) std::unique_ptr<T>
#else
#   define BDN_AUTO_PTR( T ) std::auto_ptr<T>
#endif

namespace bdn {

    struct IConfig;

    struct CaseSensitive { enum Choice {
        Yes,
        No
    }; };

    class NonCopyable {
#ifdef BDN_CONFIG_CPP11_GENERATED_METHODS
        NonCopyable( NonCopyable const& )              = delete;
        NonCopyable( NonCopyable && )                  = delete;
        NonCopyable& operator = ( NonCopyable const& ) = delete;
        NonCopyable& operator = ( NonCopyable && )     = delete;
#else
        NonCopyable( NonCopyable const& info );
        NonCopyable& operator = ( NonCopyable const& );
#endif

    protected:
        NonCopyable() {}
        virtual ~NonCopyable();
    };

    class SafeBool {
    public:
        typedef void (SafeBool::*type)() const;

        static type makeSafe( bool value ) {
            return value ? &SafeBool::trueValue : 0;
        }
    private:
        void trueValue() const {}
    };

    template<typename ContainerT>
    inline void deleteAll( ContainerT& container ) {
        typename ContainerT::const_iterator it = container.begin();
        typename ContainerT::const_iterator itEnd = container.end();
        for(; it != itEnd; ++it )
            delete *it;
    }
    template<typename AssociativeContainerT>
    inline void deleteAllValues( AssociativeContainerT& container ) {
        typename AssociativeContainerT::const_iterator it = container.begin();
        typename AssociativeContainerT::const_iterator itEnd = container.end();
        for(; it != itEnd; ++it )
            delete it->second;
    }

    bool startsWith( std::string const& s, std::string const& prefix );
    bool endsWith( std::string const& s, std::string const& suffix );
    bool contains( std::string const& s, std::string const& infix );
    void toLowerInPlace( std::string& s );
    std::string toLower( std::string const& s );
    std::string trim( std::string const& str );
    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );

    struct pluralise {
        pluralise( std::size_t count, std::string const& label );

        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );

        std::size_t m_count;
        std::string m_label;
    };

    struct SourceLineInfo {

        SourceLineInfo();
        SourceLineInfo( char const* _file, std::size_t _line );
        SourceLineInfo( SourceLineInfo const& other );
#  ifdef BDN_CONFIG_CPP11_GENERATED_METHODS
        SourceLineInfo( SourceLineInfo && )                  = default;
        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;
        SourceLineInfo& operator = ( SourceLineInfo && )     = default;
#  endif
        bool empty() const;
        bool operator == ( SourceLineInfo const& other ) const;
        bool operator < ( SourceLineInfo const& other ) const;

        std::string toStringForTest() const;

        std::string file;
        std::size_t line;
    };

    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );

    // This is just here to avoid compiler warnings with macro constants and boolean literals
    inline bool isTrue( bool value ){ return value; }
    inline bool alwaysTrue() { return true; }
    inline bool alwaysFalse() { return false; }

    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );

    void seedRng( IConfig const& config );
    unsigned int rngSeed();

    // Use this in variadic streaming macros to allow
    //    >> +StreamEndStop
    // as well as
    //    >> stuff +StreamEndStop
    struct StreamEndStop {
        std::string operator+() {
            return std::string();
        }
    };
    /*template<typename T>
    T const& operator + ( T const& value, StreamEndStop ) {
        return value;
    }*/
}

#define BDN_INTERNAL_LINEINFO ::bdn::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
#define BDN_INTERNAL_ERROR( msg ) ::bdn::throwLogicError( msg, BDN_INTERNAL_LINEINFO );

#include <ostream>

namespace bdn {

    class NotImplementedException : public std::exception
    {
    public:
        NotImplementedException( SourceLineInfo const& lineInfo );
        NotImplementedException( NotImplementedException const& ) {}

        virtual ~NotImplementedException() BDN_NOEXCEPT {}

        virtual const char* what() const BDN_NOEXCEPT;

    private:
        std::string m_what;
        SourceLineInfo m_lineInfo;
    };

} // end namespace bdn

///////////////////////////////////////////////////////////////////////////////
#define BDN_NOT_IMPLEMENTED throw bdn::NotImplementedException( BDN_INTERNAL_LINEINFO )

// #included from: internal/catch_context.h
#define TWOBLUECUBES_BDN_CONTEXT_H_INCLUDED

// #included from: catch_interfaces_generators.h
#define TWOBLUECUBES_BDN_INTERFACES_GENERATORS_H_INCLUDED

#include <string>

namespace bdn {

    struct IGeneratorInfo {
        virtual ~IGeneratorInfo();
        virtual bool moveNext() = 0;
        virtual std::size_t getCurrentIndex() const = 0;
    };

    struct IGeneratorsForTest {
        virtual ~IGeneratorsForTest();

        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;
        virtual bool moveNext() = 0;
    };

    IGeneratorsForTest* createGeneratorsForTest();

} // end namespace bdn

// #included from: catch_ptr.hpp
#define TWOBLUECUBES_BDN_PTR_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace bdn {

    // An intrusive reference counting smart pointer.
    // T must implement addRef() and release() methods
    // typically implementing the IShared interface
    template<typename T>
    class Ptr {
    public:
        Ptr() : m_p( BDN_NULL ){}
        Ptr( T* p ) : m_p( p ){
            if( m_p )
                m_p->addRef();
        }
        Ptr( Ptr const& other ) : m_p( other.m_p ){
            if( m_p )
                m_p->addRef();
        }
        ~Ptr(){
            if( m_p )
                m_p->release();
        }
        void reset() {
            if( m_p )
                m_p->release();
            m_p = BDN_NULL;
        }
        Ptr& operator = ( T* p ){
            Ptr temp( p );
            swap( temp );
            return *this;
        }
        Ptr& operator = ( Ptr const& other ){
            Ptr temp( other );
            swap( temp );
            return *this;
        }
        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
        T* get() const{ return m_p; }
        T& operator*() const { return *m_p; }
        T* operator->() const { return m_p; }
        bool operator !() const { return m_p == BDN_NULL; }
        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != BDN_NULL ); }

    private:
        T* m_p;
    };

    struct IShared : NonCopyable {
        virtual ~IShared();
        virtual void addRef() const = 0;
        virtual void release() const = 0;
    };

    template<typename T = IShared>
    struct SharedImpl : T {

        SharedImpl() : m_rc( 0 ){}

        virtual void addRef() const {
            ++m_rc;
        }
        virtual void release() const {
            if( --m_rc == 0 )
                delete this;
        }

        mutable unsigned int m_rc;
    };

} // end namespace bdn

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include <memory>
#include <vector>
#include <stdlib.h>

namespace bdn {

    class TestCase;
    class Stream;
    struct IResultCapture;
    struct IRunner;
    struct IGeneratorsForTest;
    struct IConfig;

    struct IContext
    {
        virtual ~IContext();

        virtual IResultCapture* getResultCapture() = 0;
        virtual IRunner* getRunner() = 0;
        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;
        virtual bool advanceGeneratorsForCurrentTest() = 0;
        virtual Ptr<IConfig const> getConfig() const = 0;
    };

    struct IMutableContext : IContext
    {
        virtual ~IMutableContext();
        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
        virtual void setRunner( IRunner* runner ) = 0;
        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;
    };

    IContext& getCurrentContext();
    IMutableContext& getCurrentMutableContext();
    void cleanUpContext();
    Stream createStream( std::string const& streamName );

}

// #included from: internal/catch_test_registry.hpp
#define TWOBLUECUBES_BDN_TEST_REGISTRY_HPP_INCLUDED

// #included from: catch_interfaces_testcase.h
#define TWOBLUECUBES_BDN_INTERFACES_TESTCASE_H_INCLUDED

#include <vector>

namespace bdn {

    class TestSpec;

    struct ITestCase : IShared {
        virtual void invoke () const = 0;
    protected:
        virtual ~ITestCase();
    };

    class TestCase;
    struct IConfig;

    struct ITestCaseRegistry {
        virtual ~ITestCaseRegistry();
        virtual std::vector<TestCase> const& getAllTests() const = 0;
        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
    };

    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );

}

namespace bdn {

template<typename C>
class MethodTestCase : public SharedImpl<ITestCase> {

public:
    MethodTestCase( void (C::*method)() ) : m_method( method ) {}

    virtual void invoke() const {
        C obj;
        (obj.*m_method)();
    }

private:
    virtual ~MethodTestCase() {}

    void (C::*m_method)();
};

typedef void(*TestFunction)();

struct NameAndDesc {
    NameAndDesc( const char* _name = "", const char* _description= "" )
    : name( _name ), description( _description )
    {}

    const char* name;
    const char* description;
};

void registerTestCase
    (   ITestCase* testCase,
        char const* className,
        NameAndDesc const& nameAndDesc,
        SourceLineInfo const& lineInfo );

struct AutoReg {

    AutoReg
        (   TestFunction function,
            SourceLineInfo const& lineInfo,
            NameAndDesc const& nameAndDesc );

    template<typename C>
    AutoReg
        (   void (C::*method)(),
            char const* className,
            NameAndDesc const& nameAndDesc,
            SourceLineInfo const& lineInfo ) {

        registerTestCase
            (   new MethodTestCase<C>( method ),
                className,
                nameAndDesc,
                lineInfo );
    }

    ~AutoReg();

private:
    AutoReg( AutoReg const& );
    void operator= ( AutoReg const& );
};

void registerTestCaseFunction
    (   TestFunction function,
        SourceLineInfo const& lineInfo,
        NameAndDesc const& nameAndDesc );

} // end namespace bdn

#ifdef BDN_CONFIG_VARIADIC_MACROS
    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_TESTCASE( ... ) \
        static void INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )(); \
        namespace{ bdn::AutoReg INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( autoTestCaseRegistrar )( &INTERNAL_BDN_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ ), BDN_INTERNAL_LINEINFO, bdn::NameAndDesc( __VA_ARGS__ ) ); }\
        static void INTERNAL_BDN_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ )()

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        namespace{ bdn::AutoReg INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( autoMethodAsTestCaseRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, bdn::NameAndDesc( __VA_ARGS__ ), BDN_INTERNAL_LINEINFO ); }

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_TEST_CASE_METHOD( ClassName, ... )\
        namespace{ \
            struct INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) : ClassName{ \
                void test(); \
            }; \
            bdn::AutoReg INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( autoTestCaseMethodRegistrar ) ( &INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test, #ClassName, bdn::NameAndDesc( __VA_ARGS__ ), BDN_INTERNAL_LINEINFO ); \
        } \
        void INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test()

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_REGISTER_TESTCASE( Function, ... ) \
        bdn::AutoReg( Function, BDN_INTERNAL_LINEINFO, bdn::NameAndDesc( __VA_ARGS__ ) );

#else
    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_TESTCASE( Name, Desc ) \
        static void INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )(); \
        namespace{ bdn::AutoReg INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( autoTestCaseRegistrar )( &INTERNAL_BDN_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ ), BDN_INTERNAL_LINEINFO, bdn::NameAndDesc( Name, Desc ) ); }\
        static void INTERNAL_BDN_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ )()

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \
        namespace{ bdn::AutoReg INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( autoMethodAsTestCaseRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, bdn::NameAndDesc( Name, Desc ), BDN_INTERNAL_LINEINFO ); }

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_TEST_CASE_METHOD( ClassName, TestName, Desc )\
        namespace{ \
            struct INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) : ClassName{ \
                void test(); \
            }; \
            bdn::AutoReg INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( autoTestCaseMethodRegistrar ) ( &INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test, #ClassName, bdn::NameAndDesc( TestName, Desc ), BDN_INTERNAL_LINEINFO ); \
        } \
        void INTERNAL_BDN_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test()

    ///////////////////////////////////////////////////////////////////////////////
    #define INTERNAL_BDN_REGISTER_TESTCASE( Function, Name, Desc ) \
        bdn::AutoReg( Function, BDN_INTERNAL_LINEINFO, bdn::NameAndDesc( Name, Desc ) );
#endif




// #included from: internal/catch_capture.hpp
#define TWOBLUECUBES_BDN_CAPTURE_HPP_INCLUDED

// #included from: catch_result_builder.h
#define TWOBLUECUBES_BDN_RESULT_BUILDER_H_INCLUDED

// #included from: catch_result_type.h
#define TWOBLUECUBES_BDN_RESULT_TYPE_H_INCLUDED

namespace bdn {

    // ResultWas::OfType enum
    struct ResultWas { enum OfType {
        Unknown = -1,
        Ok = 0,
        Info = 1,
        Warning = 2,

        FailureBit = 0x10,

        ExpressionFailed = FailureBit | 1,
        ExplicitFailure = FailureBit | 2,

        Exception = 0x100 | FailureBit,

        ThrewException = Exception | 1,
        DidntThrowException = Exception | 2,

        FatalErrorCondition = 0x200 | FailureBit

    }; };

    inline bool isOk( ResultWas::OfType resultType ) {
        return ( resultType & ResultWas::FailureBit ) == 0;
    }
    inline bool isJustInfo( int flags ) {
        return flags == ResultWas::Info;
    }

    // ResultDisposition::Flags enum
    struct ResultDisposition { enum Flags {
        Normal = 0x01,

        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        FalseTest = 0x04,           // Prefix expression with !
        SuppressFail = 0x08         // Failures are reported but do not fail the test
    }; };

    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
    }

    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }
    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }

} // end namespace bdn

// #included from: catch_assertionresult.h
#define TWOBLUECUBES_BDN_ASSERTIONRESULT_H_INCLUDED

#include <string>

namespace bdn {

    struct AssertionInfo
    {
        AssertionInfo() {}
        AssertionInfo(  std::string const& _macroName,
                        SourceLineInfo const& _lineInfo,
                        std::string const& _capturedExpression,
                        ResultDisposition::Flags _resultDisposition );

        std::string macroName;
        SourceLineInfo lineInfo;
        std::string capturedExpression;
        ResultDisposition::Flags resultDisposition;
    };

    struct AssertionResultData
    {
        AssertionResultData() : resultType( ResultWas::Unknown ) {}

        std::string reconstructedExpression;
        std::string message;
        ResultWas::OfType resultType;
    };

    class AssertionResult {
    public:
        AssertionResult();
        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
        ~AssertionResult();
#  ifdef BDN_CONFIG_CPP11_GENERATED_METHODS
         AssertionResult( AssertionResult const& )              = default;
         AssertionResult( AssertionResult && )                  = default;
         AssertionResult& operator = ( AssertionResult const& ) = default;
         AssertionResult& operator = ( AssertionResult && )     = default;
#  endif

        bool isOk() const;
        bool succeeded() const;
        ResultWas::OfType getResultType() const;
        bool hasExpression() const;
        bool hasMessage() const;
        std::string getExpression() const;
        std::string getExpressionInMacro() const;
        bool hasExpandedExpression() const;
        std::string getExpandedExpression() const;
        std::string getMessage() const;
        SourceLineInfo getSourceInfo() const;
        std::string getTestMacroName() const;

		void suppressFailure();

    protected:
        AssertionInfo m_info;
        AssertionResultData m_resultData;
    };

} // end namespace bdn

// #included from: catch_matchers.hpp
#define TWOBLUECUBES_BDN_MATCHERS_HPP_INCLUDED

namespace bdn {
namespace Matchers {
    namespace Impl {

    namespace Generic {
        template<typename ExpressionT> class AllOf;
        template<typename ExpressionT> class AnyOf;
        template<typename ExpressionT> class Not;
    }

    template<typename ExpressionT>
    struct Matcher : SharedImpl<IShared>
    {
        typedef ExpressionT ExpressionType;

        virtual ~Matcher() {}
        virtual Ptr<Matcher> clone() const = 0;
        virtual bool match( ExpressionT const& expr ) const = 0;
        virtual std::string toStringForTest() const = 0;

        Generic::AllOf<ExpressionT> operator && ( Matcher<ExpressionT> const& other ) const;
        Generic::AnyOf<ExpressionT> operator || ( Matcher<ExpressionT> const& other ) const;
        Generic::Not<ExpressionT> operator ! () const;
    };

    template<typename DerivedT, typename ExpressionT>
    struct MatcherImpl : Matcher<ExpressionT> {

        virtual Ptr<Matcher<ExpressionT> > clone() const {
            return Ptr<Matcher<ExpressionT> >( new DerivedT( static_cast<DerivedT const&>( *this ) ) );
        }
    };

    namespace Generic {
        template<typename ExpressionT>
        class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {
        public:
            explicit Not( Matcher<ExpressionT> const& matcher ) : m_matcher(matcher.clone()) {}
            Not( Not const& other ) : m_matcher( other.m_matcher ) {}

            virtual bool match( ExpressionT const& expr ) const BDN_OVERRIDE {
                return !m_matcher->match( expr );
            }

            virtual std::string toStringForTest() const BDN_OVERRIDE {
                return "not " + m_matcher->toStringForTest();
            }
        private:
            Ptr< Matcher<ExpressionT> > m_matcher;
        };

        template<typename ExpressionT>
        class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {
        public:

            AllOf() {}
            AllOf( AllOf const& other ) : m_matchers( other.m_matchers ) {}

            AllOf& add( Matcher<ExpressionT> const& matcher ) {
                m_matchers.push_back( matcher.clone() );
                return *this;
            }
            virtual bool match( ExpressionT const& expr ) const
            {
                for( std::size_t i = 0; i < m_matchers.size(); ++i )
                    if( !m_matchers[i]->match( expr ) )
                        return false;
                return true;
            }
            virtual std::string toStringForTest() const {
                std::ostringstream oss;
                oss << "( ";
                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
                    if( i != 0 )
                        oss << " and ";
                    oss << m_matchers[i]->toStringForTest();
                }
                oss << " )";
                return oss.str();
            }

            AllOf operator && ( Matcher<ExpressionT> const& other ) const {
                AllOf allOfExpr( *this );
                allOfExpr.add( other );
                return allOfExpr;
            }

        private:
            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
        };

        template<typename ExpressionT>
        class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {
        public:

            AnyOf() {}
            AnyOf( AnyOf const& other ) : m_matchers( other.m_matchers ) {}

            AnyOf& add( Matcher<ExpressionT> const& matcher ) {
                m_matchers.push_back( matcher.clone() );
                return *this;
            }
            virtual bool match( ExpressionT const& expr ) const
            {
                for( std::size_t i = 0; i < m_matchers.size(); ++i )
                    if( m_matchers[i]->match( expr ) )
                        return true;
                return false;
            }
            virtual std::string toStringForTest() const {
                std::ostringstream oss;
                oss << "( ";
                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
                    if( i != 0 )
                        oss << " or ";
                    oss << m_matchers[i]->toStringForTest();
                }
                oss << " )";
                return oss.str();
            }

            AnyOf operator || ( Matcher<ExpressionT> const& other ) const {
                AnyOf anyOfExpr( *this );
                anyOfExpr.add( other );
                return anyOfExpr;
            }

        private:
            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
        };

    } // namespace Generic

    template<typename ExpressionT>
    Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator && ( Matcher<ExpressionT> const& other ) const {
        Generic::AllOf<ExpressionT> allOfExpr;
        allOfExpr.add( *this );
        allOfExpr.add( other );
        return allOfExpr;
    }

    template<typename ExpressionT>
    Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator || ( Matcher<ExpressionT> const& other ) const {
        Generic::AnyOf<ExpressionT> anyOfExpr;
        anyOfExpr.add( *this );
        anyOfExpr.add( other );
        return anyOfExpr;
    }

    template<typename ExpressionT>
    Generic::Not<ExpressionT> Matcher<ExpressionT>::operator ! () const {
        return Generic::Not<ExpressionT>( *this );
    }

    namespace StdString {

        inline std::string makeString( std::string const& str ) { return str; }
        inline std::string makeString( const char* str ) { return str ? std::string( str ) : std::string(); }

        struct CasedString
        {
            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
            :   m_caseSensitivity( caseSensitivity ),
                m_str( adjustString( str ) )
            {}
            std::string adjustString( std::string const& str ) const {
                return m_caseSensitivity == CaseSensitive::No
                    ? toLower( str )
                    : str;

            }
            std::string toStringSuffix() const
            {
                return m_caseSensitivity == CaseSensitive::No
                    ? " (case insensitive)"
                    : "";
            }
            CaseSensitive::Choice m_caseSensitivity;
            std::string m_str;
        };

        struct Equals : MatcherImpl<Equals, std::string> {
            Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
            :   m_data( str, caseSensitivity )
            {}
            Equals( Equals const& other ) : m_data( other.m_data ){}

            virtual ~Equals();

            virtual bool match( std::string const& expr ) const {
                return m_data.m_str == m_data.adjustString( expr );;
            }
            virtual std::string toStringForTest() const {
                return "equals: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
            }

            CasedString m_data;
        };

        struct Contains : MatcherImpl<Contains, std::string> {
            Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
            : m_data( substr, caseSensitivity ){}
            Contains( Contains const& other ) : m_data( other.m_data ){}

            virtual ~Contains();

            virtual bool match( std::string const& expr ) const {
                return m_data.adjustString( expr ).find( m_data.m_str ) != std::string::npos;
            }
            virtual std::string toStringForTest() const {
                return "contains: \"" + m_data.m_str  + "\"" + m_data.toStringSuffix();
            }

            CasedString m_data;
        };

        struct StartsWith : MatcherImpl<StartsWith, std::string> {
            StartsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
            : m_data( substr, caseSensitivity ){}

            StartsWith( StartsWith const& other ) : m_data( other.m_data ){}

            virtual ~StartsWith();

            virtual bool match( std::string const& expr ) const {
                return m_data.adjustString( expr ).find( m_data.m_str ) == 0;
            }
            virtual std::string toStringForTest() const {
                return "starts with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
            }

            CasedString m_data;
        };

        struct EndsWith : MatcherImpl<EndsWith, std::string> {
            EndsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
            : m_data( substr, caseSensitivity ){}
            EndsWith( EndsWith const& other ) : m_data( other.m_data ){}

            virtual ~EndsWith();

            virtual bool match( std::string const& expr ) const {
                return m_data.adjustString( expr ).find( m_data.m_str ) == expr.size() - m_data.m_str.size();
            }
            virtual std::string toStringForTest() const {
                return "ends with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
            }

            CasedString m_data;
        };
    } // namespace StdString
    } // namespace Impl

    // The following functions create the actual matcher objects.
    // This allows the types to be inferred
    template<typename ExpressionT>
    inline Impl::Generic::Not<ExpressionT> Not( Impl::Matcher<ExpressionT> const& m ) {
        return Impl::Generic::Not<ExpressionT>( m );
    }

    template<typename ExpressionT>
    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,
                                                    Impl::Matcher<ExpressionT> const& m2 ) {
        return Impl::Generic::AllOf<ExpressionT>().add( m1 ).add( m2 );
    }
    template<typename ExpressionT>
    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,
                                                    Impl::Matcher<ExpressionT> const& m2,
                                                    Impl::Matcher<ExpressionT> const& m3 ) {
        return Impl::Generic::AllOf<ExpressionT>().add( m1 ).add( m2 ).add( m3 );
    }
    template<typename ExpressionT>
    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,
                                                    Impl::Matcher<ExpressionT> const& m2 ) {
        return Impl::Generic::AnyOf<ExpressionT>().add( m1 ).add( m2 );
    }
    template<typename ExpressionT>
    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,
                                                    Impl::Matcher<ExpressionT> const& m2,
                                                    Impl::Matcher<ExpressionT> const& m3 ) {
        return Impl::Generic::AnyOf<ExpressionT>().add( m1 ).add( m2 ).add( m3 );
    }

    inline Impl::StdString::Equals      Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        return Impl::StdString::Equals( str, caseSensitivity );
    }
    inline Impl::StdString::Equals      Equals( const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        return Impl::StdString::Equals( Impl::StdString::makeString( str ), caseSensitivity );
    }
    inline Impl::StdString::Contains    Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        return Impl::StdString::Contains( substr, caseSensitivity );
    }
    inline Impl::StdString::Contains    Contains( const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        return Impl::StdString::Contains( Impl::StdString::makeString( substr ), caseSensitivity );
    }
    inline Impl::StdString::StartsWith  StartsWith( std::string const& substr ) {
        return Impl::StdString::StartsWith( substr );
    }
    inline Impl::StdString::StartsWith  StartsWith( const char* substr ) {
        return Impl::StdString::StartsWith( Impl::StdString::makeString( substr ) );
    }
    inline Impl::StdString::EndsWith    EndsWith( std::string const& substr ) {
        return Impl::StdString::EndsWith( substr );
    }
    inline Impl::StdString::EndsWith    EndsWith( const char* substr ) {
        return Impl::StdString::EndsWith( Impl::StdString::makeString( substr ) );
    }

} // namespace Matchers

using namespace Matchers;

} // namespace bdn

namespace bdn {

    struct TestFailureException{};

    template<typename T> class ExpressionLhs;

    struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;

    struct CopyableStream {
        CopyableStream() {}
        CopyableStream( CopyableStream const& other ) {
            oss << other.oss.str();
        }
        CopyableStream& operator=( CopyableStream const& other ) {
            oss.str("");
            oss << other.oss.str();
            return *this;
        }
        std::ostringstream oss;
    };

    class ResultBuilder {
    public:
        ResultBuilder(  char const* macroName,
                        SourceLineInfo const& lineInfo,
                        char const* capturedExpression,
                        ResultDisposition::Flags resultDisposition,
                        char const* secondArg = "" );

        template<typename T>
        ExpressionLhs<T const&> operator <= ( T const& operand );
        ExpressionLhs<bool> operator <= ( bool value );

        template<typename T>
        ResultBuilder& operator << ( T const& value ) {
            m_stream.oss << value;
            return *this;
        }

        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );
        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );

        ResultBuilder& setResultType( ResultWas::OfType result );
        ResultBuilder& setResultType( bool result );
        ResultBuilder& setLhs( std::string const& lhs );
        ResultBuilder& setRhs( std::string const& rhs );
        ResultBuilder& setOp( std::string const& op );

        void endExpression();

        std::string reconstructExpression() const;
        AssertionResult build() const;

        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );
        void captureResult( ResultWas::OfType resultType );
        void captureExpression();
        void captureExpectedException( std::string const& expectedMessage );
        void captureExpectedException( Matchers::Impl::Matcher<std::string> const& matcher );
        void handleResult( AssertionResult const& result );
        void react();
        bool shouldDebugBreak() const;
        bool allowThrows() const;

		void markFailed();

    private:
        AssertionInfo m_assertionInfo;
        AssertionResultData m_data;
        struct ExprComponents {
            ExprComponents() : testFalse( false ) {}
            bool testFalse;
            std::string lhs, rhs, op;
        } m_exprComponents;
        CopyableStream m_stream;

        bool m_shouldDebugBreak;
        bool m_shouldThrow;
    };

} // namespace bdn

// Include after due to circular dependency:
// #included from: catch_expression_lhs.hpp
#define TWOBLUECUBES_BDN_EXPRESSION_LHS_HPP_INCLUDED

// #included from: catch_evaluate.hpp
#define TWOBLUECUBES_BDN_EVALUATE_HPP_INCLUDED

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
#endif

#include <cstddef>

namespace bdn {
namespace Internal {

    enum Operator {
        IsEqualTo,
        IsNotEqualTo,
        IsLessThan,
        IsGreaterThan,
        IsLessThanOrEqualTo,
        IsGreaterThanOrEqualTo
    };

    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };
    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };
    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };
    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };
    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };
    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };
    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };
    
    template<typename T>
    inline T& opCast(T const& t) { return const_cast<T&>(t); }

// nullptr_t support based on pull request #154 from Konstantin Baumann
#ifdef BDN_CONFIG_CPP11_NULLPTR
    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
#endif // BDN_CONFIG_CPP11_NULLPTR


    // So the compare overloads can be operator agnostic we convey the operator as a template
    // enum, which is used to specialise an Evaluator for doing the comparison.
    template<typename T1, typename T2, Operator Op>
    class Evaluator{};

    template<typename T1, typename T2>
    struct Evaluator<T1, T2, IsEqualTo> {
        static bool evaluate( T1 const& lhs, T2 const& rhs) {
            return opCast( lhs ) ==  opCast( rhs );
        }
    };
    template<typename T1, typename T2>
    struct Evaluator<T1, T2, IsNotEqualTo> {
        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
            return opCast( lhs ) != opCast( rhs );
        }
    };
    template<typename T1, typename T2>
    struct Evaluator<T1, T2, IsLessThan> {
        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
            return opCast( lhs ) < opCast( rhs );
        }
    };
    template<typename T1, typename T2>
    struct Evaluator<T1, T2, IsGreaterThan> {
        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
            return opCast( lhs ) > opCast( rhs );
        }
    };
    template<typename T1, typename T2>
    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {
        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
            return opCast( lhs ) >= opCast( rhs );
        }
    };
    template<typename T1, typename T2>
    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {
        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
            return opCast( lhs ) <= opCast( rhs );
        }
    };

    template<Operator Op, typename T1, typename T2>
    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {
        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
    }

    // This level of indirection allows us to specialise for integer types
    // to avoid signed/ unsigned warnings

    // "base" overload
    template<Operator Op, typename T1, typename T2>
    bool compare( T1 const& lhs, T2 const& rhs ) {
        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
    }

    // unsigned X to int
    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {
        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
    }
    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {
        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
    }
    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {
        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
    }

    // unsigned X to long
    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {
        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
    }
    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {
        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
    }
    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {
        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
    }

    // int to unsigned X
    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
    }
    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
    }
    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
    }

    // long to unsigned X
    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }

    // pointer to long (when comparing against NULL)
    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {
        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
    }
    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {
        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
    }

    // pointer to int (when comparing against NULL)
    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {
        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
    }
    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {
        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
    }

#ifdef BDN_CONFIG_CPP11_LONG_LONG

    // long long to unsigned X
    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {
        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
    }

    // unsigned long long to X
    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {
        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {
        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {
        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
    }
    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {
        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
    }

    // pointer to long long (when comparing against NULL)
    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {
        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
    }
    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {
        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
    }
#endif // BDN_CONFIG_CPP11_LONG_LONG

#ifdef BDN_CONFIG_CPP11_NULLPTR
    
    // pointer to nullptr_t (when comparing against nullptr)
    template<Operator Op, typename T> bool compare( std::nullptr_t lhs, T* rhs ) {
        T* p( nullptr );    // this temporary variable is needed so that the code compiled
                            // with ios automatic reference counting (ARC). nullptr cannot
                            // be implicity converted to a reference counted pointer, so
                            // passing it to evaluate(T*,T*) directly would cause an error.
                            // With this temp object we explicitly create a null pointer variable
                            // so this will work.
        return Evaluator<T*, T*, Op>::evaluate( p, rhs );
    }
    
    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t rhs ) {
        T* p( nullptr );    // this temporary variable is needed so that the code compiled
                            // with ios automatic reference counting (ARC). nullptr cannot
                            // be implicity converted to a reference counted pointer, so
                            // passing it to evaluate(T*,T*) directly would cause an error.
                            // With this temp object we explicitly create a null pointer variable
                            // so this will work.
        return Evaluator<T*, T*, Op>::evaluate( lhs, p );
    }
#endif // BDN_CONFIG_CPP11_NULLPTR



} // end of namespace Internal
} // end of namespace bdn

#ifdef _MSC_VER
#pragma warning(pop)
#endif

// #included from: catch_tostring.h
#define TWOBLUECUBES_BDN_TOSTRING_H_INCLUDED

#include <sstream>
#include <iomanip>
#include <limits>
#include <vector>
#include <cstddef>

#ifdef __OBJC__
// #included from: catch_objc_arc.hpp
#define TWOBLUECUBES_BDN_OBJC_ARC_HPP_INCLUDED

#import <Foundation/Foundation.h>

#ifdef __has_feature
#define BDN_ARC_ENABLED __has_feature(objc_arc)
#else
#define BDN_ARC_ENABLED 0
#endif

void arcSafeRelease( NSObject* obj );
id performOptionalSelector( id obj, SEL sel );

#if !BDN_ARC_ENABLED
inline void arcSafeRelease( NSObject* obj ) {
    [obj release];
}
inline id performOptionalSelector( id obj, SEL sel ) {
    if( [obj respondsToSelector: sel] )
        return [obj performSelector: sel];
    return nil;
}
#define BDN_UNSAFE_UNRETAINED
#define BDN_ARC_STRONG
#else
inline void arcSafeRelease( NSObject* ){}
inline id performOptionalSelector( id obj, SEL sel ) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
#endif
    if( [obj respondsToSelector: sel] )
        return [obj performSelector: sel];
#ifdef __clang__
#pragma clang diagnostic pop
#endif
    return nil;
}
#define BDN_UNSAFE_UNRETAINED __unsafe_unretained
#define BDN_ARC_STRONG __strong
#endif

#endif

#ifdef BDN_CONFIG_CPP11_TUPLE
#include <tuple>
#endif

#ifdef BDN_CONFIG_CPP11_IS_ENUM
#include <type_traits>
#endif

namespace bdn {

// Why we're here.
template<typename T>
std::string toStringForTest( T const& value );

// Built in overloads

std::string toStringForTest( StringImpl<Utf8StringData> const& value );
std::string toStringForTest( StringImpl<Utf16StringData> const& value );
std::string toStringForTest( StringImpl<WideStringData> const& value );
std::string toStringForTest( StringImpl<Utf32StringData> const& value );
std::string toStringForTest( std::string const& value );
std::string toStringForTest( std::wstring const& value );
std::string toStringForTest( std::u16string const& value );
std::string toStringForTest( std::u32string const& value );
std::string toStringForTest( const char* const value );
std::string toStringForTest( char* const value );
std::string toStringForTest( const wchar_t* const value );
std::string toStringForTest( wchar_t* const value );
std::string toStringForTest( const char16_t* const value );
std::string toStringForTest( char16_t* const value );
std::string toStringForTest( const char32_t* const value );
std::string toStringForTest( char32_t* const value );
std::string toStringForTest( int value );
std::string toStringForTest( unsigned long value );
std::string toStringForTest( unsigned int value );
std::string toStringForTest( const double value );
std::string toStringForTest( const float value );
std::string toStringForTest( bool value );
std::string toStringForTest( char value );
std::string toStringForTest( signed char value );
std::string toStringForTest( unsigned char value );

#ifdef BDN_CONFIG_CPP11_LONG_LONG
std::string toStringForTest( long long value );
std::string toStringForTest( unsigned long long value );
#endif

#ifdef BDN_CONFIG_CPP11_NULLPTR
std::string toStringForTest( std::nullptr_t );
#endif

#ifdef __OBJC__
    std::string toStringForTest( NSString const * const& nsstring );
    std::string toStringForTest( NSString * BDN_ARC_STRONG const& nsstring );
    std::string toStringForTest( NSObject* const& nsObject );
#endif

std::string toStringForTest( const Point& point);
std::string toStringForTest( const Size& size);
std::string toStringForTest( const Rect& rect);
std::string toStringForTest( const Margin& margin);
std::string toStringForTest( const UiLength& length);
std::string toStringForTest( const UiMargin& margin);
std::string toStringForTest( const UiSize& size);



namespace Detail {

    const std::string& getUnprintableString();

    struct BorgType {
        template<typename T> BorgType( T const& );
    };

    struct TrueType { char sizer[1]; };
    struct FalseType { char sizer[2]; };

    TrueType& testStreamable( std::ostream& );
    FalseType testStreamable( FalseType );

    FalseType operator<<( std::ostream const&, BorgType const& );

    template<typename T>
    struct IsStreamInsertable {
        static std::ostream &s;
        static T  const&t;
        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };
    };

#if defined(BDN_CONFIG_CPP11_IS_ENUM)
    template<typename T,
             bool IsEnum = std::is_enum<T>::value
             >
    struct EnumStringMaker
    {
        static std::string convert( T const& ) { return getUnprintableString(); }
    };

    template<typename T>
    struct EnumStringMaker<T,true>
    {
        static std::string convert( T const& v )
        {
            return ::bdn::toStringForTest(
                static_cast<typename std::underlying_type<T>::type>(v)
                );
        }
    };
#endif
    template<bool C>
    struct StringMakerBase {
#if defined(BDN_CONFIG_CPP11_IS_ENUM)
        template<typename T>
        static std::string convert( T const& v )
        {
            return EnumStringMaker<T>::convert( v );
        }
#else
        template<typename T>
        static std::string convert( T const& ) { return getUnprintableString(); }
#endif
    };

    template<>
    struct StringMakerBase<true> {
        template<typename T>
        static std::string convert( T const& _value ) {
            std::ostringstream oss;
            oss << _value;
            return oss.str();
        }
    };

    std::string rawMemoryToString( const void *object, std::size_t size );

    template<typename T>
    inline std::string rawMemoryToString( const T& object ) {
      return rawMemoryToString( &object, sizeof(object) );
    }

} // end namespace Detail

template<typename T>
struct StringMaker :
    Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};

template<typename T>
struct StringMaker<T*> {
    template<typename U>
    static std::string convert( U* p ) {
        if( !p )
            return "NULL";
        else
            return Detail::rawMemoryToString( p );
    }
};

template<typename R, typename C>
struct StringMaker<R C::*> {
    static std::string convert( R C::* p ) {
        if( !p )
            return "NULL";
        else
            return Detail::rawMemoryToString( p );
    }
};

namespace Detail {
    template<typename InputIterator>
    std::string rangeToString( InputIterator first, InputIterator last );
}

//template<typename T, typename Allocator>
//struct StringMaker<std::vector<T, Allocator> > {
//    static std::string convert( std::vector<T,Allocator> const& v ) {
//        return Detail::rangeToString( v.begin(), v.end() );
//    }
//};

template<typename T, typename Allocator>
std::string toStringForTest( std::vector<T,Allocator> const& v ) {
    return Detail::rangeToString( v.begin(), v.end() );
}

#ifdef BDN_CONFIG_CPP11_TUPLE

// toStringForTest for tuples
namespace TupleDetail {
  template<
      typename Tuple,
      std::size_t N = 0,
      bool = (N < std::tuple_size<Tuple>::value)
      >
  struct ElementPrinter {
      static void print( const Tuple& tuple, std::ostream& os )
      {
          os << ( N ? ", " : " " )
             << bdn::toStringForTest(std::get<N>(tuple));
          ElementPrinter<Tuple,N+1>::print(tuple,os);
      }
  };

  template<
      typename Tuple,
      std::size_t N
      >
  struct ElementPrinter<Tuple,N,false> {
      static void print( const Tuple&, std::ostream& ) {}
  };

}

template<typename ...Types>
struct StringMaker<std::tuple<Types...>> {

    static std::string convert( const std::tuple<Types...>& tuple )
    {
        std::ostringstream os;
        os << '{';
        TupleDetail::ElementPrinter<std::tuple<Types...>>::print( tuple, os );
        os << " }";
        return os.str();
    }
};
#endif // BDN_CONFIG_CPP11_TUPLE

namespace Detail {
    template<typename T>
    std::string makeString( T const& value ) {
        return StringMaker<T>::convert( value );
    }
} // end namespace Detail

/// \brief converts any type to a string
///
/// The default template forwards on to ostringstream - except when an
/// ostringstream overload does not exist - in which case it attempts to detect
/// that and writes {?}.
/// Overload (not specialise) this template for custom typs that you don't want
/// to provide an ostream overload for.
template<typename T>
std::string toStringForTest( T const& value ) {
    return StringMaker<T>::convert( value );
}

    namespace Detail {
    template<typename InputIterator>
    std::string rangeToString( InputIterator first, InputIterator last ) {
        std::ostringstream oss;
        oss << "{ ";
        if( first != last ) {
            oss << bdn::toStringForTest( *first );
            for( ++first ; first != last ; ++first )
                oss << ", " << bdn::toStringForTest( *first );
        }
        oss << " }";
        return oss.str();
    }
}

} // end namespace bdn

namespace bdn {

// Wraps the LHS of an expression and captures the operator and RHS (if any) -
// wrapping them all in a ResultBuilder object
template<typename T>
class ExpressionLhs {
    ExpressionLhs& operator = ( ExpressionLhs const& );
#  ifdef BDN_CONFIG_CPP11_GENERATED_METHODS
    ExpressionLhs& operator = ( ExpressionLhs && ) = delete;
#  endif

public:
    ExpressionLhs( ResultBuilder& rb, T lhs ) : m_rb( rb ), m_lhs( lhs ) {}
#  ifdef BDN_CONFIG_CPP11_GENERATED_METHODS
    ExpressionLhs( ExpressionLhs const& ) = default;
    ExpressionLhs( ExpressionLhs && )     = default;
#  endif

    template<typename RhsT>
    ResultBuilder& operator == ( RhsT const& rhs ) {
        return captureExpression<Internal::IsEqualTo>( rhs );
    }

    ResultBuilder& operator == ( std::nullptr_t rhs ) {
        return captureExpression<Internal::IsEqualTo>( rhs );
    }

#ifdef __cplusplus_cli
	// needed to work around a compiler bug in the Visual Studio C++/CLI compiler.
	ResultBuilder& operator == ( size_t rhs ) {
        return captureExpression<Internal::IsEqualTo>( rhs );
    }
#endif



    template<typename RhsT>
    ResultBuilder& operator != ( RhsT const& rhs ) {
        return captureExpression<Internal::IsNotEqualTo>( rhs );
    }

    ResultBuilder& operator != (std::nullptr_t rhs) {
        return captureExpression<Internal::IsNotEqualTo>( rhs );
    }

#ifdef __cplusplus_cli
	// needed to work around a compiler bug in the Visual Studio C++/CLI compiler.
	ResultBuilder& operator != (size_t rhs) {
        return captureExpression<Internal::IsNotEqualTo>( (size_t)rhs );
    }
#endif

    template<typename RhsT>
    ResultBuilder& operator < ( RhsT const& rhs ) {
        return captureExpression<Internal::IsLessThan>( rhs );
    }

	ResultBuilder& operator < ( std::nullptr_t rhs ) {
        return captureExpression<Internal::IsLessThan>( rhs );
    }

    template<typename RhsT>
    ResultBuilder& operator > ( RhsT const& rhs ) {
        return captureExpression<Internal::IsGreaterThan>( rhs );
    }

	ResultBuilder& operator > ( std::nullptr_t rhs ) {
        return captureExpression<Internal::IsGreaterThan>( rhs );
    }

    template<typename RhsT>
    ResultBuilder& operator <= ( RhsT const& rhs ) {
        return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );
    }

	ResultBuilder& operator <= ( std::nullptr_t rhs ) {
        return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );
    }

    template<typename RhsT>
    ResultBuilder& operator >= ( RhsT const& rhs ) {
        return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );
    }

	ResultBuilder& operator >= ( std::nullptr_t rhs ) {
        return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );
    }

    ResultBuilder& operator == ( bool rhs ) {
        return captureExpression<Internal::IsEqualTo>( rhs );
    }

    ResultBuilder& operator != ( bool rhs ) {
        return captureExpression<Internal::IsNotEqualTo>( rhs );
    }

    void endExpression() {
        bool value = m_lhs ? true : false;
        m_rb
            .setLhs( bdn::toStringForTest( value ) )
            .setResultType( value )
            .endExpression();
    }

    // Only simple binary expressions are allowed on the LHS.
    // If more complex compositions are required then place the sub expression in parentheses
    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + ( RhsT const& );
    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - ( RhsT const& );
    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / ( RhsT const& );
    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * ( RhsT const& );
    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );
    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );

private:
    template<Internal::Operator Op, typename RhsT>
    ResultBuilder& captureExpression( RhsT const& rhs ) {
        return m_rb
            .setResultType( Internal::compare<Op>( m_lhs, rhs ) )
            .setLhs( bdn::toStringForTest( m_lhs ) )
            .setRhs( bdn::toStringForTest( rhs ) )
            .setOp( Internal::OperatorTraits<Op>::getName() );
    }

private:
    ResultBuilder& m_rb;
    T m_lhs;
};

} // end namespace bdn


namespace bdn {

    template<typename T>
    inline ExpressionLhs<T const&> ResultBuilder::operator <= ( T const& operand ) {
        return ExpressionLhs<T const&>( *this, operand );
    }

    inline ExpressionLhs<bool> ResultBuilder::operator <= ( bool value ) {
        return ExpressionLhs<bool>( *this, value );
    }

} // namespace bdn

// #included from: catch_message.h
#define TWOBLUECUBES_BDN_MESSAGE_H_INCLUDED

#include <string>

namespace bdn {

    struct MessageInfo {
        MessageInfo(    std::string const& _macroName,
                        SourceLineInfo const& _lineInfo,
                        ResultWas::OfType _type );

        std::string macroName;
        SourceLineInfo lineInfo;
        ResultWas::OfType type;
        std::string message;
        unsigned int sequence;

        bool operator == ( MessageInfo const& other ) const {
            return sequence == other.sequence;
        }
        bool operator < ( MessageInfo const& other ) const {
            return sequence < other.sequence;
        }
    private:
        static unsigned int globalCount;
    };

    struct MessageBuilder {
        MessageBuilder( std::string const& macroName,
                        SourceLineInfo const& lineInfo,
                        ResultWas::OfType type )
        : m_info( macroName, lineInfo, type )
        {}

        template<typename T>
        MessageBuilder& operator << ( T const& value ) {
            m_stream << value;
            return *this;
        }

        MessageInfo m_info;
        std::ostringstream m_stream;
    };

    class ScopedMessage {
    public:
        ScopedMessage( MessageBuilder const& builder );
        ScopedMessage( ScopedMessage const& other );
        ~ScopedMessage();

        MessageInfo m_info;
    };

} // end namespace bdn

// #included from: catch_interfaces_capture.h
#define TWOBLUECUBES_BDN_INTERFACES_CAPTURE_H_INCLUDED

#include <string>

namespace bdn {

    class TestCase;
    class AssertionResult;
    struct AssertionInfo;
    struct SectionInfo;
    struct SectionEndInfo;
    struct MessageInfo;
    class ScopedMessageBuilder;
    struct Counts;

    struct IResultCapture {

        virtual ~IResultCapture();

        virtual void assertionEnded( AssertionResult const& result ) = 0;
        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
                                        Counts& assertions ) = 0;
        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        virtual void popScopedMessage( MessageInfo const& message ) = 0;

        virtual std::string getCurrentTestName() const = 0;
        virtual bool lastResultSucceeded() const = 0;

		virtual bool isCurrentTestExpectedToFail() const=0;

        virtual void handleFatalErrorCondition( std::string const& message ) = 0;
    };

    IResultCapture& getResultCapture();
}

// #included from: catch_debugger.h
#define TWOBLUECUBES_BDN_DEBUGGER_H_INCLUDED

// #included from: catch_platform.h
#define TWOBLUECUBES_BDN_PLATFORM_H_INCLUDED


#include <string>

#include <bdn/debug.h>


// #included from: catch_interfaces_runner.h
#define TWOBLUECUBES_BDN_INTERFACES_RUNNER_H_INCLUDED

namespace bdn {
    class TestCase;

    struct IRunner {
        virtual ~IRunner();
        virtual bool aborting() const = 0;
				
        virtual void continueSectionWhenIdle(std::function<void()> continuationFunc )=0;
        virtual void continueSectionAfterAbsoluteSeconds(double seconds, std::function<void()> continuationFunc )=0;
        virtual void continueSectionAfterRunSeconds(double seconds, std::function<void()> continuationFunc )=0;
        virtual void continueSectionInThread(std::function<void()> continuationFunc )=0;
    };
}

///////////////////////////////////////////////////////////////////////////////
// In the event of a failure works out if the debugger needs to be invoked
// and/or an exception thrown and takes appropriate action.
// This needs to be done as a macro so the debugger will stop in the user
// source code rather than in bdn library code
#define INTERNAL_BDN_REACT( resultBuilder ) \
    if( resultBuilder.shouldDebugBreak() ) BDN_DEBUG_BREAK(); \
    resultBuilder.react();

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_TEST( expr, resultDisposition, macroName ) \
    do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        try { \
            ( __catchResult <= expr ).endExpression(); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( bdn::ResultDisposition::Normal ); \
        } \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::isTrue( false && (expr) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_IF( expr, resultDisposition, macroName ) \
    INTERNAL_BDN_TEST( expr, resultDisposition, macroName ); \
    if( bdn::getResultCapture().lastResultSucceeded() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_ELSE( expr, resultDisposition, macroName ) \
    INTERNAL_BDN_TEST( expr, resultDisposition, macroName ); \
    if( !bdn::getResultCapture().lastResultSucceeded() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_NO_THROW( expr, resultDisposition, macroName ) \
    do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        try { \
            expr; \
            __catchResult.captureResult( bdn::ResultWas::Ok ); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( resultDisposition ); \
        } \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_THROWS( expr, resultDisposition, matcher, macroName ) \
    do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #expr, resultDisposition, #matcher ); \
        if( __catchResult.allowThrows() ) \
            try { \
                expr; \
                __catchResult.captureResult( bdn::ResultWas::DidntThrowException ); \
            } \
            catch( ... ) { \
                __catchResult.captureExpectedException( matcher ); \
            } \
        else \
            __catchResult.captureResult( bdn::ResultWas::Ok ); \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_THROWS_AS( expr, exceptionType, resultDisposition, macroName ) \
    do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        if( __catchResult.allowThrows() ) \
            try { \
                expr; \
                __catchResult.captureResult( bdn::ResultWas::DidntThrowException ); \
            } \
            catch( exceptionType ) { \
                __catchResult.captureResult( bdn::ResultWas::Ok ); \
            } \
            catch( ... ) { \
                __catchResult.useActiveException( resultDisposition ); \
            } \
        else \
            __catchResult.captureResult( bdn::ResultWas::Ok ); \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::alwaysFalse() )




///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_IN( val, container, negate, resultDisposition, macroName ) \
	do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #val ", " #container, resultDisposition ); \
        try { \
			bool _result = false; \
			std::string _rhs; \
			for(auto item: container) \
			{ \
				if(val==item) \
					_result = true; \
				if(!_rhs.empty()) \
					_rhs += ", "; \
				_rhs += bdn::toStringForTest(item); \
			} \
			_rhs = "["+_rhs+"]"; \
			__catchResult.setLhs(bdn::toStringForTest(val) ); \
			__catchResult.setRhs(_rhs ); \
			__catchResult.setOp( negate ? "not in" : "in");  \
			if(negate) \
				_result = !_result; \
			__catchResult.captureResult( _result ? bdn::ResultWas::Ok : bdn::ResultWas::ExpressionFailed ); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( bdn::ResultDisposition::Normal ); \
        } \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::alwaysFalse() ) // expr here is never evaluated at runtime but it forces the compiler to give it a look



#define INTERNAL_BDN_ALMOST_EQUAL( value, expectedValue, maxDeviation, resultDisposition, macroName ) \
	do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #value ", " #expectedValue ", " #maxDeviation, resultDisposition ); \
        try { \
            /* capture the concrete values, in case the parameters are a function call or similar.*/ \
            auto _val = value; \
            auto _expectedVal = expectedValue; \
            auto _dev = maxDeviation; \
			bool _result = (_val>=_expectedVal-_dev && _val<=_expectedVal+_dev); \
			__catchResult.setLhs(bdn::toStringForTest(_val) ); \
			__catchResult.setRhs(bdn::toStringForTest(_expectedVal) ); \
			__catchResult.setOp( "~~");  \
			__catchResult.captureResult( _result ? bdn::ResultWas::Ok : bdn::ResultWas::ExpressionFailed ); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( bdn::ResultDisposition::Normal ); \
        } \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::alwaysFalse() ) // expr here is never evaluated at runtime but it forces the compiler to give it a look


///////////////////////////////////////////////////////////////////////////////
#ifdef BDN_CONFIG_VARIADIC_MACROS
    #define INTERNAL_BDN_MSG( messageType, resultDisposition, macroName, ... ) \
        do { \
            bdn::ResultBuilder __catchREResult( macroName, BDN_INTERNAL_LINEINFO, "", resultDisposition ); \
            __catchResult << __VA_ARGS__ + ::bdn::StreamEndStop(); \
            __catchResult.captureResult( messageType ); \
            INTERNAL_BDN_REACT( __catchResult ) \
        } while( bdn::alwaysFalse() )
#else
    #define INTERNAL_BDN_MSG( messageType, resultDisposition, macroName, log ) \
        do { \
            bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, "", resultDisposition ); \
            __catchResult << log + ::bdn::StreamEndStop(); \
            __catchResult.captureResult( messageType ); \
            INTERNAL_BDN_REACT( __catchResult ) \
        } while( bdn::alwaysFalse() )
#endif

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_INFO( log, macroName ) \
    bdn::ScopedMessage INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( scopedMessage ) = bdn::MessageBuilder( macroName, BDN_INTERNAL_LINEINFO, bdn::ResultWas::Info ) << log;

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CHECK_THAT( arg, matcher, resultDisposition, macroName ) \
    do { \
        bdn::ResultBuilder __catchResult( macroName, BDN_INTERNAL_LINEINFO, #arg ", " #matcher, resultDisposition ); \
        try { \
            std::string matcherAsString = (matcher).toStringForTest(); \
            __catchResult \
                .setLhs( bdn::toStringForTest( arg ) ) \
                .setRhs( matcherAsString == bdn::Detail::getUnprintableString() ? #matcher : matcherAsString ) \
                .setOp( "matches" ) \
                .setResultType( (matcher).match( arg ) ); \
            __catchResult.captureExpression(); \
        } catch( ... ) { \
            __catchResult.useActiveException( resultDisposition | bdn::ResultDisposition::ContinueOnFailure ); \
        } \
        INTERNAL_BDN_REACT( __catchResult ) \
    } while( bdn::alwaysFalse() )



#define INTERNAL_BDN_CONTINUE_SECTION_WHEN_IDLE_WITH( continuationFunc ) \
    bdn::getCurrentContext().getRunner()->continueSectionWhenIdle( continuationFunc )

#define INTERNAL_BDN_CONTINUE_SECTION_IN_THREAD_WITH( continuationFunc ) \
    bdn::getCurrentContext().getRunner()->continueSectionInThread( continuationFunc )


#define INTERNAL_BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH( seconds, continuationFunc ) \
    bdn::getCurrentContext().getRunner()->continueSectionAfterAbsoluteSeconds( seconds, continuationFunc )

#define INTERNAL_BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH( seconds, continuationFunc ) \
    bdn::getCurrentContext().getRunner()->continueSectionAfterRunSeconds( seconds, continuationFunc )

#define INTERNAL_BDN_EXPECT_TEST_PROGRAMMING_ERROR() \
	if( const IRunner::ExpectTestProgrammingError& INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER(catch_internal_expect_test_programming_error) = bdn::IRunner::ExpectTestProgrammingError( bdn::getCurrentContext()->getRunner() ) )



// #included from: internal/catch_section.h
#define TWOBLUECUBES_BDN_SECTION_H_INCLUDED

// #included from: catch_section_info.h
#define TWOBLUECUBES_BDN_SECTION_INFO_H_INCLUDED

// #included from: catch_totals.hpp
#define TWOBLUECUBES_BDN_TOTALS_HPP_INCLUDED

#include <cstddef>

namespace bdn {

    struct Counts {
        Counts() : passed( 0 ), failed( 0 ), failedButOk( 0 ) {}

        Counts operator - ( Counts const& other ) const {
            Counts diff;
            diff.passed = passed - other.passed;
            diff.failed = failed - other.failed;
            diff.failedButOk = failedButOk - other.failedButOk;
            return diff;
        }
        Counts& operator += ( Counts const& other ) {
            passed += other.passed;
            failed += other.failed;
            failedButOk += other.failedButOk;
            return *this;
        }

        std::size_t total() const {
            return passed + failed + failedButOk;
        }
        bool allPassed() const {
            return failed == 0 && failedButOk == 0;
        }
        bool allOk() const {
            return failed == 0;
        }

        std::size_t passed;
        std::size_t failed;
        std::size_t failedButOk;
    };

    struct Totals {

        Totals operator - ( Totals const& other ) const {
            Totals diff;
            diff.assertions = assertions - other.assertions;
			diff.tests = tests - other.tests;
            diff.testCases = testCases - other.testCases;
            return diff;
        }

        Totals delta( Totals const& prevTotals ) const {
            Totals diff = *this - prevTotals;
            if( diff.assertions.failed > 0 )
                ++diff.testCases.failed;
            else if( diff.assertions.failedButOk > 0 )
                ++diff.testCases.failedButOk;
            else
                ++diff.testCases.passed;
            return diff;
        }

        Totals& operator += ( Totals const& other ) {
            assertions += other.assertions;
			tests += other.tests;
            testCases += other.testCases;
            return *this;
        }

        Counts assertions;
		Counts tests;
        Counts testCases;
    };
}

namespace bdn {

    struct SectionInfo {
        SectionInfo
            (   SourceLineInfo const& _lineInfo,
                std::string const& _name,
                std::string const& _description = std::string() );

        std::string name;
        std::string description;
        SourceLineInfo lineInfo;
    };

    struct SectionEndInfo {
        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )
        : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )
        {}

        SectionInfo sectionInfo;
        Counts prevAssertions;
        double durationInSeconds;
    };

} // end namespace bdn

// #included from: catch_timer.h
#define TWOBLUECUBES_BDN_TIMER_H_INCLUDED

#ifdef BDN_PLATFORM_WINDOWS
typedef unsigned long long uint64_t;
#else
#include <stdint.h>
#endif

namespace bdn {

    class Timer {
    public:
        Timer() : m_ticks( 0 ) {}
        void start();
        unsigned int getElapsedMicroseconds() const;
        unsigned int getElapsedMilliseconds() const;
        double getElapsedSeconds() const;

    private:
        uint64_t m_ticks;
    };

} // namespace bdn

#include <string>

namespace bdn {

    class Section : NonCopyable {
    public:
        Section( SectionInfo const& info );
        ~Section();

        // This indicates whether the section should be executed or not
        operator bool() const;

    private:
        SectionInfo m_info;

        std::string m_name;
        Counts m_assertions;
        bool m_sectionIncluded;
        Timer m_timer;
    };

} // end namespace bdn

#ifdef BDN_CONFIG_VARIADIC_MACROS
    #define INTERNAL_BDN_SECTION( ... ) \
        if( bdn::Section const& INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( catch_internal_Section ) = bdn::SectionInfo( BDN_INTERNAL_LINEINFO, __VA_ARGS__ ) )
#else
    #define INTERNAL_BDN_SECTION( name, desc ) \
        if( bdn::Section const& INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( catch_internal_Section ) = bdn::SectionInfo( BDN_INTERNAL_LINEINFO, name, desc ) )
#endif




// #included from: internal/catch_generators.hpp
#define TWOBLUECUBES_BDN_GENERATORS_HPP_INCLUDED

#include <iterator>
#include <vector>
#include <string>
#include <stdlib.h>

namespace bdn {

template<typename T>
struct IGenerator {
    virtual ~IGenerator() {}

    // note: we cannot use pure virtual functions for the following.
    // It will cause a compilation error with G++. Instead we add an implementation
    // that only throws an exception.

    virtual T getValue( std::size_t index ) const
    {
        throw std::logic_error("Not implemented: bdn::IGenerator::getValue");
    }

    virtual std::size_t size () const
    {
        throw std::logic_error("Not implemented: bdn::IGenerator::size");
    }
};

template<typename T>
class BetweenGenerator : public IGenerator<T> {
public:
    BetweenGenerator( T from, T to ) : m_from( from ), m_to( to ){}

    virtual T getValue( std::size_t index ) const {
        return m_from+static_cast<int>( index );
    }

    virtual std::size_t size() const {
        return static_cast<std::size_t>( 1+m_to-m_from );
    }

private:

    T m_from;
    T m_to;
};

template<typename T>
class ValuesGenerator : public IGenerator<T> {
public:
    ValuesGenerator(){}

    void add( T value ) {
        m_values.push_back( value );
    }

    virtual T getValue( std::size_t index ) const {
        return m_values[index];
    }

    virtual std::size_t size() const {
        return m_values.size();
    }

private:
    std::vector<T> m_values;
};

template<typename T>
class CompositeGenerator {
public:
    CompositeGenerator() : m_totalSize( 0 ) {}

    // *** Move semantics, similar to auto_ptr ***
    CompositeGenerator( CompositeGenerator& other )
    :   m_fileInfo( other.m_fileInfo ),
        m_totalSize( 0 )
    {
        move( other );
    }

    CompositeGenerator& setFileInfo( const char* fileInfo ) {
        m_fileInfo = fileInfo;
        return *this;
    }

    ~CompositeGenerator() {
        deleteAll( m_composed );
    }

    operator T () const {
        size_t overallIndex = getCurrentContext().getGeneratorIndex( m_fileInfo, m_totalSize );

        typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
        typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
        for( size_t index = 0; it != itEnd; ++it )
        {
            const IGenerator<T>* generator = *it;
            if( overallIndex >= index && overallIndex < index + generator->size() )
            {
                return generator->getValue( overallIndex-index );
            }
            index += generator->size();
        }
        BDN_INTERNAL_ERROR( "Indexed past end of generated range" );
        return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
    }

    void add( const IGenerator<T>* generator ) {
        m_totalSize += generator->size();
        m_composed.push_back( generator );
    }

    CompositeGenerator& then( CompositeGenerator& other ) {
        move( other );
        return *this;
    }

    CompositeGenerator& then( T value ) {
        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        valuesGen->add( value );
        add( valuesGen );
        return *this;
    }

private:

    void move( CompositeGenerator& other ) {
        std::copy( other.m_composed.begin(), other.m_composed.end(), std::back_inserter( m_composed ) );
        m_totalSize += other.m_totalSize;
        other.m_composed.clear();
    }

    std::vector<const IGenerator<T>*> m_composed;
    std::string m_fileInfo;
    size_t m_totalSize;
};

// this used to be in a sub-namespace. Don't see the point.
//{
    template<typename T>
    CompositeGenerator<T> between( T from, T to ) {
        CompositeGenerator<T> generators;
        generators.add( new BetweenGenerator<T>( from, to ) );
        return generators;
    }

    template<typename T>
    CompositeGenerator<T> values( T val1, T val2 ) {
        CompositeGenerator<T> generators;
        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        valuesGen->add( val1 );
        valuesGen->add( val2 );
        generators.add( valuesGen );
        return generators;
    }

    template<typename T>
    CompositeGenerator<T> values( T val1, T val2, T val3 ){
        CompositeGenerator<T> generators;
        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        valuesGen->add( val1 );
        valuesGen->add( val2 );
        valuesGen->add( val3 );
        generators.add( valuesGen );
        return generators;
    }

    template<typename T>
    CompositeGenerator<T> values( T val1, T val2, T val3, T val4 ) {
        CompositeGenerator<T> generators;
        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        valuesGen->add( val1 );
        valuesGen->add( val2 );
        valuesGen->add( val3 );
        valuesGen->add( val4 );
        generators.add( valuesGen );
        return generators;
    }

//} // end namespace Generators
// using namespace Generators;

} // end namespace bdn

#define INTERNAL_BDN_LINESTR2( line ) #line
#define INTERNAL_BDN_LINESTR( line ) INTERNAL_BDN_LINESTR2( line )

#define INTERNAL_BDN_GENERATE( expr ) expr.setFileInfo( __FILE__ "(" INTERNAL_BDN_LINESTR( __LINE__ ) ")" )

// #included from: internal/catch_interfaces_exception.h
#define TWOBLUECUBES_BDN_INTERFACES_EXCEPTION_H_INCLUDED

#include <string>
#include <vector>

// #included from: catch_interfaces_registry_hub.h
#define TWOBLUECUBES_BDN_INTERFACES_REGISTRY_HUB_H_INCLUDED

#include <string>

namespace bdn {

    class TestCase;
    struct ITestCaseRegistry;
    struct IExceptionTranslatorRegistry;
    struct IExceptionTranslator;
    struct IReporterRegistry;
    struct IReporterFactory;

    struct IRegistryHub {
        virtual ~IRegistryHub();

        virtual IReporterRegistry const& getReporterRegistry() const = 0;
        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
    };

    struct IMutableRegistryHub {
        virtual ~IMutableRegistryHub();
        virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) = 0;
        virtual void registerListener( Ptr<IReporterFactory> const& factory ) = 0;
        virtual void registerTest( TestCase const& testInfo ) = 0;
        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
    };

    IRegistryHub& getRegistryHub();
    IMutableRegistryHub& getMutableRegistryHub();
    void cleanUp();
    std::string translateActiveException();

}

namespace bdn {

    typedef std::string(*exceptionTranslateFunction)();

    struct IExceptionTranslator;
    typedef std::vector<const IExceptionTranslator*> ExceptionTranslators;

    struct IExceptionTranslator {
        virtual ~IExceptionTranslator();
        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
    };

    struct IExceptionTranslatorRegistry {
        virtual ~IExceptionTranslatorRegistry();

        virtual std::string translateActiveException() const = 0;
    };

    class ExceptionTranslatorRegistrar {
        template<typename T>
        class ExceptionTranslator : public IExceptionTranslator {
        public:

            ExceptionTranslator( std::string(*translateFunction)( T& ) )
            : m_translateFunction( translateFunction )
            {}

            virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const BDN_OVERRIDE {
                try {
                    if( it == itEnd )
                        throw;
                    else
                        return (*it)->translate( it+1, itEnd );
                }
                catch( T& ex ) {
                    return m_translateFunction( ex );
                }
            }

        protected:
            std::string(*m_translateFunction)( T& );
        };

    public:
        template<typename T>
        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
            getMutableRegistryHub().registerTranslator
                ( new ExceptionTranslator<T>( translateFunction ) );
        }
    };
}

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_BDN_TRANSLATE_EXCEPTION( signature ) \
    static std::string INTERNAL_BDN_UNIQUE_NAME( catch_internal_ExceptionTranslator )( signature ); \
    namespace{ bdn::ExceptionTranslatorRegistrar INTERNAL_BDN_UNIQUE_NAME_POSSIBLY_WITH_COUNTER( catch_internal_ExceptionRegistrar )( &INTERNAL_BDN_UNIQUE_NAME( catch_internal_ExceptionTranslator ) ); }\
    static std::string INTERNAL_BDN_UNIQUE_NAME(  catch_internal_ExceptionTranslator )( signature )

// #included from: internal/catch_approx.hpp
#define TWOBLUECUBES_BDN_APPROX_HPP_INCLUDED

#include <cmath>
#include <limits>

namespace bdn {
namespace Detail {

    class Approx {
    public:
        explicit Approx ( double value )
        :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
            m_scale( 1.0 ),
            m_value( value )
        {}

        Approx( Approx const& other )
        :   m_epsilon( other.m_epsilon ),
            m_scale( other.m_scale ),
            m_value( other.m_value )
        {}

        static Approx custom() {
            return Approx( 0 );
        }

        Approx operator()( double value ) {
            Approx approx( value );
            approx.epsilon( m_epsilon );
            approx.scale( m_scale );
            return approx;
        }

        friend bool operator == ( double lhs, Approx const& rhs ) {
            // Thanks to Richard Harris for his help refining this formula
            return fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
        }

        friend bool operator == ( Approx const& lhs, double rhs ) {
            return operator==( rhs, lhs );
        }

        friend bool operator != ( double lhs, Approx const& rhs ) {
            return !operator==( lhs, rhs );
        }

        friend bool operator != ( Approx const& lhs, double rhs ) {
            return !operator==( rhs, lhs );
        }

        Approx& epsilon( double newEpsilon ) {
            m_epsilon = newEpsilon;
            return *this;
        }

        Approx& scale( double newScale ) {
            m_scale = newScale;
            return *this;
        }

        std::string toStringForTest() const {
            std::ostringstream oss;
            oss << "Approx( " << bdn::toStringForTest( m_value ) << " )";
            return oss.str();
        }

    private:
        double m_epsilon;
        double m_scale;
        double m_value;
    };
}

template<>
inline std::string toStringForTest<Detail::Approx>( Detail::Approx const& value ) {
    return value.toStringForTest();
}

} // end namespace bdn

// #included from: internal/catch_interfaces_tag_alias_registry.h
#define TWOBLUECUBES_BDN_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED

// #included from: catch_tag_alias.h
#define TWOBLUECUBES_BDN_TAG_ALIAS_H_INCLUDED

#include <string>

namespace bdn {

    struct TagAlias {
        TagAlias( std::string _tag, SourceLineInfo _lineInfo ) : tag( _tag ), lineInfo( _lineInfo ) {}

        std::string tag;
        SourceLineInfo lineInfo;
    };

    struct RegistrarForTagAliases {
        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
    };

} // end namespace bdn

#define BDN_REGISTER_TAG_ALIAS( alias, spec ) namespace{ bdn::RegistrarForTagAliases INTERNAL_BDN_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, BDN_INTERNAL_LINEINFO ); }
// #included from: catch_option.hpp
#define TWOBLUECUBES_BDN_OPTION_HPP_INCLUDED

namespace bdn {

    // An optional type
    template<typename T>
    class Option {
    public:
        Option() : nullableValue( BDN_NULL ) {}
        Option( T const& _value )
        : nullableValue( new( storage ) T( _value ) )
        {}
        Option( Option const& _other )
        : nullableValue( _other ? new( storage ) T( *_other ) : BDN_NULL )
        {}

        ~Option() {
            reset();
        }

        Option& operator= ( Option const& _other ) {
            if( &_other != this ) {
                reset();
                if( _other )
                    nullableValue = new( storage ) T( *_other );
            }
            return *this;
        }
        Option& operator = ( T const& _value ) {
            reset();
            nullableValue = new( storage ) T( _value );
            return *this;
        }

        void reset() {
            if( nullableValue )
                nullableValue->~T();
            nullableValue = BDN_NULL;
        }

        T& operator*() { return *nullableValue; }
        T const& operator*() const { return *nullableValue; }
        T* operator->() { return nullableValue; }
        const T* operator->() const { return nullableValue; }

        T valueOr( T const& defaultValue ) const {
            return nullableValue ? *nullableValue : defaultValue;
        }

        bool some() const { return nullableValue != BDN_NULL; }
        bool none() const { return nullableValue == BDN_NULL; }

        bool operator !() const { return nullableValue == BDN_NULL; }
        operator SafeBool::type() const {
            return SafeBool::makeSafe( some() );
        }

    private:
        T* nullableValue;
        char storage[sizeof(T)];
    };

} // end namespace bdn

namespace bdn {

    struct ITagAliasRegistry {
        virtual ~ITagAliasRegistry();
        virtual Option<TagAlias> find( std::string const& alias ) const = 0;
        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;

        static ITagAliasRegistry const& get();
    };

} // end namespace bdn

// These files are included here so the single_include script doesn't put them
// in the conditionally compiled sections
// #included from: internal/catch_test_case_info.h
#define TWOBLUECUBES_BDN_TEST_CASE_INFO_H_INCLUDED

#include <string>
#include <set>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace bdn {

    struct ITestCase;

    struct TestCaseInfo {
        enum SpecialProperties{
            None = 0,
            IsHidden = 1 << 1,
            ShouldFail = 1 << 2,
            MayFail = 1 << 3,
            Throws = 1 << 4
        };

        TestCaseInfo(   std::string const& _name,
                        std::string const& _className,
                        std::string const& _description,
                        std::set<std::string> const& _tags,
                        SourceLineInfo const& _lineInfo );

        TestCaseInfo( TestCaseInfo const& other );

        friend void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags );

        bool isHidden() const;
        bool throws() const;
        bool okToFail() const;
        bool expectedToFail() const;

        std::string name;
        std::string className;
        std::string description;
        std::set<std::string> tags;
        std::set<std::string> lcaseTags;
        std::string tagsAsString;
        SourceLineInfo lineInfo;
        SpecialProperties properties;
    };

    class TestCase : public TestCaseInfo {
    public:

        TestCase( ITestCase* testCase, TestCaseInfo const& info );
        TestCase( TestCase const& other );

        TestCase withName( std::string const& _newName ) const;

        void invoke() const;

        TestCaseInfo const& getTestCaseInfo() const;

        void swap( TestCase& other );
        bool operator == ( TestCase const& other ) const;
        bool operator < ( TestCase const& other ) const;
        TestCase& operator = ( TestCase const& other );

    private:
        Ptr<ITestCase> test;
    };

    TestCase makeTestCase(  ITestCase* testCase,
                            std::string const& className,
                            std::string const& name,
                            std::string const& description,
                            SourceLineInfo const& lineInfo );
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif


#ifdef __OBJC__
// #included from: internal/catch_objc.hpp
#define TWOBLUECUBES_BDN_OBJC_HPP_INCLUDED

#import <objc/runtime.h>

#include <string>

// NB. Any general catch headers included here must be included
// in catch.hpp first to make sure they are included by the single
// header for non obj-usage

///////////////////////////////////////////////////////////////////////////////
// This protocol is really only here for (self) documenting purposes, since
// all its methods are optional.
@protocol OcFixture

@optional

-(void) setUp;
-(void) tearDown;

@end

namespace bdn {

    class OcMethod : public SharedImpl<ITestCase> {

    public:
        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}

        virtual void invoke() const {
            id obj = [[m_cls alloc] init];

            performOptionalSelector( obj, @selector(setUp)  );
            performOptionalSelector( obj, m_sel );
            performOptionalSelector( obj, @selector(tearDown)  );

            arcSafeRelease( obj );
        }
    private:
        virtual ~OcMethod() {}

        Class m_cls;
        SEL m_sel;
    };

    namespace Detail{

        inline std::string getAnnotation(   Class cls,
                                            std::string const& annotationName,
                                            std::string const& testCaseName ) {
            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
            SEL sel = NSSelectorFromString( selStr );
            arcSafeRelease( selStr );
            id value = performOptionalSelector( cls, sel );
            if( value )
                return [(NSString*)value UTF8String];
            return "";
        }
    }

    inline size_t registerTestMethods() {
        size_t noTestMethods = 0;
        int noClasses = objc_getClassList( BDN_NULL, 0 );

        Class* classes = (BDN_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
        objc_getClassList( classes, noClasses );

        for( int c = 0; c < noClasses; c++ ) {
            Class cls = classes[c];
            {
                u_int count;
                Method* methods = class_copyMethodList( cls, &count );
                for( u_int m = 0; m < count ; m++ ) {
                    SEL selector = method_getName(methods[m]);
                    std::string methodName = sel_getName(selector);
                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
                        std::string testCaseName = methodName.substr( 15 );
                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
                        const char* className = class_getName( cls );

                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo() ) );
                        noTestMethods++;
                    }
                }
                free(methods);
            }
        }
        return noTestMethods;
    }

    namespace Matchers {
        namespace Impl {
        namespace NSStringMatchers {

            template<typename MatcherT>
            struct StringHolder : MatcherImpl<MatcherT, NSString*>{
                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
                StringHolder() {
                    arcSafeRelease( m_substr );
                }

                NSString* m_substr;
            };

            struct Equals : StringHolder<Equals> {
                Equals( NSString* substr ) : StringHolder( substr ){}

                virtual bool match( ExpressionType const& str ) const {
                    return  (str != nil || m_substr == nil ) &&
                            [str isEqualToString:m_substr];
                }

                virtual std::string toStringForTest() const {
                    return "equals string: " + bdn::toStringForTest( m_substr );
                }
            };

            struct Contains : StringHolder<Contains> {
                Contains( NSString* substr ) : StringHolder( substr ){}

                virtual bool match( ExpressionType const& str ) const {
                    return  (str != nil || m_substr == nil ) &&
                            [str rangeOfString:m_substr].location != NSNotFound;
                }

                virtual std::string toStringForTest() const {
                    return "contains string: " + bdn::toStringForTest( m_substr );
                }
            };

            struct StartsWith : StringHolder<StartsWith> {
                StartsWith( NSString* substr ) : StringHolder( substr ){}

                virtual bool match( ExpressionType const& str ) const {
                    return  (str != nil || m_substr == nil ) &&
                            [str rangeOfString:m_substr].location == 0;
                }

                virtual std::string toStringForTest() const {
                    return "starts with: " + bdn::toStringForTest( m_substr );
                }
            };
            struct EndsWith : StringHolder<EndsWith> {
                EndsWith( NSString* substr ) : StringHolder( substr ){}

                virtual bool match( ExpressionType const& str ) const {
                    return  (str != nil || m_substr == nil ) &&
                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
                }

                virtual std::string toStringForTest() const {
                    return "ends with: " + bdn::toStringForTest( m_substr );
                }
            };

        } // namespace NSStringMatchers
        } // namespace Impl

        inline Impl::NSStringMatchers::Equals
            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }

        inline Impl::NSStringMatchers::Contains
            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }

        inline Impl::NSStringMatchers::StartsWith
            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }

        inline Impl::NSStringMatchers::EndsWith
            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }

    } // namespace Matchers

    using namespace Matchers;

} // namespace bdn

///////////////////////////////////////////////////////////////////////////////
#define OC_TEST_CASE( name, desc )\
+(NSString*) INTERNAL_BDN_UNIQUE_NAME( Catch_Name_test ) \
{\
return @ name; \
}\
+(NSString*) INTERNAL_BDN_UNIQUE_NAME( Catch_Description_test ) \
{ \
return @ desc; \
} \
-(void) INTERNAL_BDN_UNIQUE_NAME( Catch_TestCase_test )

#endif







//////
#define BDN_REQUIRE( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::Normal, "BDN_REQUIRE" )
#define BDN_REQUIRE_FALSE( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::Normal | bdn::ResultDisposition::FalseTest, "BDN_REQUIRE_FALSE" )

#define BDN_REQUIRE_THROWS( expr ) INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::Normal, "", "BDN_REQUIRE_THROWS" )
#define BDN_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_BDN_THROWS_AS( expr, exceptionType, bdn::ResultDisposition::Normal, "BDN_REQUIRE_THROWS_AS" )
#define BDN_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::Normal, matcher, "BDN_REQUIRE_THROWS_WITH" )
#define BDN_REQUIRE_NOTHROW( expr ) INTERNAL_BDN_NO_THROW( expr, bdn::ResultDisposition::Normal, "BDN_REQUIRE_NOTHROW" )

#define BDN_REQUIRE_THROWS_PROGRAMMING_ERROR(expr) \
	{ \
		bdn::ExpectProgrammingError _expectProgrammingError_ ; \
		BDN_REQUIRE_THROWS_AS(expr, bdn::ProgrammingError); \
	}

#define BDN_REQUIRE_IN_MAIN_THREAD() BDN_REQUIRE( bdn::Thread::isCurrentMain() );

#define BDN_REQUIRE_ALMOST_EQUAL( value, expectedValue, maxDeviation )  INTERNAL_BDN_ALMOST_EQUAL( value, expectedValue, maxDeviation, bdn::ResultDisposition::Normal, "BDN_REQUIRE_ALMOST_EQUAL" )

#define BDN_CHECK( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECK" )
#define BDN_CHECK_FALSE( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::ContinueOnFailure | bdn::ResultDisposition::FalseTest, "BDN_CHECK_FALSE" )
#define BDN_CHECKED_IF( expr ) INTERNAL_BDN_IF( expr, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECKED_IF" )
#define BDN_CHECKED_ELSE( expr ) INTERNAL_BDN_ELSE( expr, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECKED_ELSE" )
#define BDN_CHECK_NOFAIL( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::ContinueOnFailure | bdn::ResultDisposition::SuppressFail, "BDN_CHECK_NOFAIL" )

#define BDN_CHECK_THROWS( expr )  INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECK_THROWS" )
#define BDN_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_BDN_THROWS_AS( expr, exceptionType, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECK_THROWS_AS" )
#define BDN_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::ContinueOnFailure, matcher, "BDN_CHECK_THROWS_WITH" )
#define BDN_CHECK_NOTHROW( expr ) INTERNAL_BDN_NO_THROW( expr, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECK_NOTHROW" )

#define BDN_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, bdn::ResultDisposition::ContinueOnFailure, "BDN_CHECK_THAT" )
#define BDN_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, bdn::ResultDisposition::Normal, "BDN_REQUIRE_THAT" )

#define BDN_INFO( msg ) INTERNAL_BDN_INFO( msg, "BDN_INFO" )
#define BDN_WARN( msg ) INTERNAL_BDN_MSG( bdn::ResultWas::Warning, bdn::ResultDisposition::ContinueOnFailure, "BDN_WARN", msg )
#define BDN_SCOPED_INFO( msg ) INTERNAL_BDN_INFO( msg, "BDN_INFO" )
#define BDN_CAPTURE( msg ) INTERNAL_BDN_INFO( #msg " := " << msg, "BDN_CAPTURE" )
#define BDN_SCOPED_CAPTURE( msg ) INTERNAL_BDN_INFO( #msg " := " << msg, "BDN_CAPTURE" )

#define BDN_TEST_CASE( ... ) INTERNAL_BDN_TESTCASE( __VA_ARGS__ )
#define BDN_TEST_CASE_METHOD( className, ... ) INTERNAL_BDN_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define BDN_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_BDN_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define BDN_REGISTER_TEST_CASE( ... ) INTERNAL_BDN_REGISTER_TESTCASE( __VA_ARGS__ )
#define BDN_SECTION( ... ) INTERNAL_BDN_SECTION( __VA_ARGS__ )
#define BDN_ASYNC_SECTION( sectionName, ... ) INTERNAL_BDN_ASYNC_SECTION( sectionName, __VA_ARGS__ )
#define BDN_FAIL( ... ) INTERNAL_BDN_MSG( bdn::ResultWas::ExplicitFailure, bdn::ResultDisposition::Normal, "BDN_FAIL", __VA_ARGS__ )
#define BDN_SUCCEED( ... ) INTERNAL_BDN_MSG( bdn::ResultWas::Ok, bdn::ResultDisposition::ContinueOnFailure, "BDN_SUCCEED", __VA_ARGS__ )

#define BDN_ANON_TEST_CASE() INTERNAL_BDN_TESTCASE( "", "" )

#define BDN_REGISTER_REPORTER( name, reporterType ) INTERNAL_BDN_REGISTER_REPORTER( name, reporterType )
#define BDN_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_BDN_REGISTER_LEGACY_REPORTER( name, reporterType )

#define BDN_GENERATE( expr) INTERNAL_BDN_GENERATE( expr )

// "BDD-style" convenience wrappers
#ifdef BDN_CONFIG_VARIADIC_MACROS
#define BDN_SCENARIO( ... ) BDN_TEST_CASE( "Scenario: " __VA_ARGS__ )
#define BDN_SCENARIO_METHOD( className, ... ) INTERNAL_BDN_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#else
#define BDN_SCENARIO( name, tags ) BDN_TEST_CASE( "Scenario: " name, tags )
#define BDN_SCENARIO_METHOD( className, name, tags ) INTERNAL_BDN_TEST_CASE_METHOD( className, "Scenario: " name, tags )
#endif
#define BDN_GIVEN( desc )    BDN_SECTION( std::string( "Given: ") + desc, "" )
#define BDN_WHEN( desc )     BDN_SECTION( std::string( " When: ") + desc, "" )
#define BDN_AND_WHEN( desc ) BDN_SECTION( std::string( "  And: ") + desc, "" )
#define BDN_THEN( desc )     BDN_SECTION( std::string( " Then: ") + desc, "" )
#define BDN_AND_THEN( desc ) BDN_SECTION( std::string( "  And: ") + desc, "" )




/** \def BDN_CONTINUE_SECTION_WHEN_IDLE_WITH( continuationFunc )

	\copybrief CONTINUE_SECTION_WHEN_IDLE_WITH()
	\copydetailed CONTINUE_SECTION_WHEN_IDLE_WITH()

	*/
#define BDN_CONTINUE_SECTION_WHEN_IDLE_WITH( ... ) INTERNAL_BDN_CONTINUE_SECTION_WHEN_IDLE_WITH(  __VA_ARGS__ )



/** \def BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH(seconds, continuationFunc )

	\copybrief CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH()
	\copydetailed CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH()

	*/
#define BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH( seconds, ... ) INTERNAL_BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH(seconds,  __VA_ARGS__ )


/** \def BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH(seconds, continuationFunc )

	\copybrief CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH()
	\copydetailed CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH()

	*/
#define BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH( seconds, ... ) INTERNAL_BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH(seconds,  __VA_ARGS__ )


/** \def BDN_CONTINUE_SECTION_IN_THREAD_WITH( continuationFunc )

	\copybrief CONTINUE_SECTION_IN_THREAD_WITH()
	\copydetailed CONTINUE_SECTION_IN_THREAD_WITH()

	*/
#define BDN_CONTINUE_SECTION_IN_THREAD_WITH( ... ) INTERNAL_BDN_CONTINUE_SECTION_IN_THREAD_WITH( __VA_ARGS__ )




namespace bdn
{
namespace test
{

class ContinueSectionWhenIdleStarter_
{
public:
    void operator << ( std::function<void()> continuation )
    {
        BDN_CONTINUE_SECTION_WHEN_IDLE_WITH( continuation );
    }
};

}
}

#define BDN_CONTINUE_SECTION_WHEN_IDLE(...) \
    bdn::test::ContinueSectionWhenIdleStarter_() << [__VA_ARGS__]()


namespace bdn
{
namespace test
{

class ContinueSectionAfterAbsoluteSecondsStarter_
{
public:
    ContinueSectionAfterAbsoluteSecondsStarter_(double seconds)
    {
        _seconds = seconds;
    }

    void operator << ( std::function<void()> continuation )
    {
        BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH( _seconds, continuation );
    }

private:
    double _seconds;
};

class ContinueSectionAfterRunSecondsStarter_
{
public:
    ContinueSectionAfterRunSecondsStarter_(double seconds)
    {
        _seconds = seconds;
    }

    void operator << ( std::function<void()> continuation )
    {
        BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH( _seconds, continuation );
    }

private:
    double _seconds;
};

}
}

#define BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS( seconds, ...) \
    bdn::test::ContinueSectionAfterAbsoluteSecondsStarter_(seconds) << [__VA_ARGS__]()

#define BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS( seconds, ...) \
    bdn::test::ContinueSectionAfterRunSecondsStarter_(seconds) << [__VA_ARGS__]()



namespace bdn
{
namespace test
{

class ContinueSectionInThreadStarter_
{
public:
    void operator << ( std::function<void()> continuation )
    {
        BDN_CONTINUE_SECTION_IN_THREAD_WITH( continuation );
    }
};

}
}

#define BDN_CONTINUE_SECTION_IN_THREAD(...) \
    bdn::test::ContinueSectionInThreadStarter_() << [__VA_ARGS__]()



namespace bdn
{
namespace test
{
    
class AsyncSectionStarter_
{
public:

    void operator<<(std::function<void()> continuationFunc) const
    {
        BDN_CONTINUE_SECTION_WHEN_IDLE_WITH(continuationFunc);
    }
};

}
}


#define INTERNAL_BDN_ASYNC_SECTION( sectionName, ... ) \
        INTERNAL_BDN_SECTION( sectionName ) \
            bdn::test::AsyncSectionStarter_() << [ __VA_ARGS__ ]()
            



#ifndef BDN_TEST_ONLY_PREFIXED

#define REQUIRE( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::Normal, "REQUIRE" )
#define REQUIRE_FALSE( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::Normal | bdn::ResultDisposition::FalseTest, "REQUIRE_FALSE" )

#define REQUIRE_THROWS( expr ) INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::Normal, "", "REQUIRE_THROWS" )
#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_BDN_THROWS_AS( expr, exceptionType, bdn::ResultDisposition::Normal, "REQUIRE_THROWS_AS" )
#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::Normal, matcher, "REQUIRE_THROWS_WITH" )
#define REQUIRE_NOTHROW( expr ) INTERNAL_BDN_NO_THROW( expr, bdn::ResultDisposition::Normal, "REQUIRE_NOTHROW" )


/** Verifies that the specified expression throws a ProgrammingError.

	This is very similar to REQUIRE_THROWS_AS( expr, bdn::ProgrammingError). But in
	addition to that functionality, this macro automatically uses ExpectProgrammingError
	to prevent debug breaks, asserts and logging to happen when the bdn::programmingError()
	function is called in the specified expression. See bdn::programmingError() for more information.
*/
#define REQUIRE_THROWS_PROGRAMMING_ERROR(expr) BDN_REQUIRE_THROWS_PROGRAMMING_ERROR(expr)


#define REQUIRE_IN( value, container ) INTERNAL_BDN_IN( value, container, false, bdn::ResultDisposition::Normal, "REQUIRE_IN")
#define REQUIRE_NOT_IN( value, container ) INTERNAL_BDN_IN( value, container, true, bdn::ResultDisposition::Normal, "REQUIRE_NOT_IN")

#define REQUIRE_ALMOST_EQUAL( value, expectedValue, maxDeviation )  INTERNAL_BDN_ALMOST_EQUAL( value, expectedValue, maxDeviation, bdn::ResultDisposition::Normal, "REQUIRE_ALMOST_EQUAL" )

#define REQUIRE_IN_MAIN_THREAD() REQUIRE( bdn::Thread::isCurrentMain() );

/** Checks the specified condition and records failures, but does not abort the test if the condition failed (i.e. does not throw TestFailureException
	like REQUIRE would).*/
#define CHECK( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::ContinueOnFailure, "CHECK" )
#define CHECK_FALSE( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::ContinueOnFailure | bdn::ResultDisposition::FalseTest, "CHECK_FALSE" )
#define CHECKED_IF( expr ) INTERNAL_BDN_IF( expr, bdn::ResultDisposition::ContinueOnFailure, "CHECKED_IF" )
#define CHECKED_ELSE( expr ) INTERNAL_BDN_ELSE( expr, bdn::ResultDisposition::ContinueOnFailure, "CHECKED_ELSE" )
#define CHECK_NOFAIL( expr ) INTERNAL_BDN_TEST( expr, bdn::ResultDisposition::ContinueOnFailure | bdn::ResultDisposition::SuppressFail, "CHECK_NOFAIL" )

#define CHECK_THROWS( expr )  INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::ContinueOnFailure, "", "CHECK_THROWS" )
#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_BDN_THROWS_AS( expr, exceptionType, bdn::ResultDisposition::ContinueOnFailure, "CHECK_THROWS_AS" )
#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_BDN_THROWS( expr, bdn::ResultDisposition::ContinueOnFailure, matcher, "CHECK_THROWS_WITH" )
#define CHECK_NOTHROW( expr ) INTERNAL_BDN_NO_THROW( expr, bdn::ResultDisposition::ContinueOnFailure, "CHECK_NOTHROW" )

#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, bdn::ResultDisposition::ContinueOnFailure, "CHECK_THAT" )
#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, bdn::ResultDisposition::Normal, "REQUIRE_THAT" )

#define INFO( msg ) INTERNAL_BDN_INFO( msg, "INFO" )
#define WARN( msg ) INTERNAL_BDN_MSG( bdn::ResultWas::Warning, bdn::ResultDisposition::ContinueOnFailure, "WARN", msg )
#define SCOPED_INFO( msg ) INTERNAL_BDN_INFO( msg, "INFO" )
#define CAPTURE( msg ) INTERNAL_BDN_INFO( #msg " := " << msg, "CAPTURE" )
#define SCOPED_CAPTURE( msg ) INTERNAL_BDN_INFO( #msg " := " << msg, "CAPTURE" )


#define TEST_CASE( ... ) INTERNAL_BDN_TESTCASE( __VA_ARGS__ )
#define TEST_CASE_METHOD( className, ... ) INTERNAL_BDN_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_BDN_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define REGISTER_TEST_CASE( ... ) INTERNAL_BDN_REGISTER_TESTCASE( __VA_ARGS__ )
#define SECTION( ... ) INTERNAL_BDN_SECTION( __VA_ARGS__ )


/** \def #define ASYNC_SECTION( sectionName, captures... )

    Starts a section that is executed asynchronously.

    Just as with a normal SECTION, a code block must follow that contains the
    section code. The difference is that this code will be executed asynchronously,
    as if CONTINUE_SECTION_WHEN_IDLE was used at the end of a normal section.

    There is one difference in usage compared to SECTION, though: there must be a semicolon
    at the end of the async section's code block (see example below).

    The code block after ASYNC_SECTION will actually end up being executed as a lambda function.
    The capture statement of the lambda expression are the remaining parameters of the 
    ASYNC_SECTION macro, after the section name. Often one will simply specify = here, to automatically
    capture the local variables that you use inside the continuation.
    
    This macro is primarily useful if you want pending user interface events to be executed
    between the initialization code for your test case and the actual test code. For example,
    you might set up a user interface and might want a layout cycle to happen between the
    initialization and the tests.

    Examples:

    \code

    // do some generic initalization here that applies to all sections
    P<SomeClass>    pSomeTestObject = newObj<SomeClass>();
    int             someValue = 17;
    double          someOtherValue = 42;
    ... more initialization code....

    ASYNC_SECTION("some section", = )   // capture statement is "=", i.e. capture all local variables by value
    {
        // this is the async test code.
        // pSomeTestObject, someValue and someOtherValue can all be used here, since all local variables are captured by value.
    };


    ASYNC_SECTION("some other section", pSomeTestObject, someValue )   // capture statement explicitly lists what to capture here
    {
        // we can only access pSomeTestObject and someValue here, since only those have been captured.
    };

    \endcode
*/
#define ASYNC_SECTION( sectionName, ... ) INTERNAL_BDN_ASYNC_SECTION( sectionName, __VA_ARGS__ )

#define FAIL( ... ) INTERNAL_BDN_MSG( bdn::ResultWas::ExplicitFailure, bdn::ResultDisposition::Normal, "FAIL", __VA_ARGS__ )
#define SUCCEED( ... ) INTERNAL_BDN_MSG( bdn::ResultWas::Ok, bdn::ResultDisposition::ContinueOnFailure, "SUCCEED", __VA_ARGS__ )


#define ANON_TEST_CASE() INTERNAL_BDN_TESTCASE( "", "" )


/** \def CONTINUE_SECTION_WHEN_IDLE_WITH( continuationFunc )

    Continues the current test section after all pending events and work have finished.
    Then the section resumes and the specified continuation function / lambda is called.

    This is very similar to CONTINUE_SECTION_WHEN_IDLE, except that you can pass the code to be executed as
    a function object parameter, instead of specifying it in a code block after the CONTINUE_SECTION_WHEN_IDLE statement.

    This can sometimes be useful if you want the continuation to be a real function, or a function with
    bounds parameters (using std::bind) or things like that.
    
    Apart from this difference, the macro works exactly like CONTINUE_SECTION_WHEN_IDLE.

	Example:

	\code

    void continueButtonClickTest(bool* pClicked, P<Window> pWindow)
    {
        REQUIRE( *pClicked );
    }

	TEST_CASE("ButtonClick")
	{
		P<Window> pWindow = newObj<Window>();
		P<Button> pButton = newObj<Button>();

        pWindow->setContentView(pMyButton);

        bool* pClicked = new bool;
        *pClicked = false;

        // when the button is clicked then we 
		pMyButton->onClick().subscribeVoid( 
            [pClicked]()
            {
                // set pClicked to true when the button is clicked.
                *pClicked = true;
            } );

        // schedule a button click
		P<ButtonClicker> pClicker = newObj<ButtonClicker>( pMyButton );
		pClicker->scheduleButtonClick(pMyButton);

        // *pClicked will not be true yet because the imaginary ButtonClicker object
        // requires pending UI events to be handled to execute the scheduled event.

        // So we now need user interface events to be handled, causing the click to be
        // actually executed. So we have to schedule an async continuation.
		CONTINUE_SECTION_WHEN_IDLE_WITH( std::bind( continueButtonClickTest, pClicked, pWindow) );        
    }
    
	\endcode

	*/
#define CONTINUE_SECTION_WHEN_IDLE_WITH( ... ) INTERNAL_BDN_CONTINUE_SECTION_WHEN_IDLE_WITH( __VA_ARGS__ )





/** \def CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH(seconds, continuationFunc )

    Continues the current test section after waiting for the specified number of seconds, according to the normal
    clock. Note that this macro will always wait the requested amount of time, no matter what happens on the computer.
    Also see \ref CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH, which will automatically wait longer when the CPU is under high load
    or when the test application gets suspended by the operating system.
    
    Seconds is a floating point number, so you can also specify non-integer amounts of seconds (e.g. 0.1 to wait for 100 milliseconds).

    After the delay the section is continued by calling the specified continuation function / lambda.

    This is very similar to CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS, except that you can pass the code to be executed as
    a function object parameter, instead of specifying it in a code block after the CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS statement.

    This can sometimes be useful if you want the continuation to be a real function, or a function with
    bounds parameters (using std::bind) or things like that.
    
    Apart from this difference, the macro works exactly like CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS.

	Example:

	\code

    void continueButtonClickTest(bool* pClicked, P<Window> pWindow)
    {
        REQUIRE( *pClicked );
    }

	TEST_CASE("ButtonClick")
	{
		P<Window> pWindow = newObj<Window>();
		P<Button> pButton = newObj<Button>();

        pWindow->setContentView(pMyButton);

        bool* pClicked = new bool;
        *pClicked = false;

        // when the button is clicked then we 
		pMyButton->onClick().subscribeVoid( 
            [pClicked]()
            {
                // set pClicked to true when the button is clicked.
                *pClicked = true;
            } );

        // schedule a button click
		P<ButtonClicker> pClicker = newObj<ButtonClicker>( pMyButton );
		pClicker->scheduleButtonClick(pMyButton);

        // *pClicked will not be true yet because the imaginary ButtonClicker object
        // requires pending UI events to be handled to execute the scheduled event.

        // wait for 2.5 seconds and then continue.
		CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH( 2.5, std::bind( continueButtonClickTest, pClicked, pWindow) );        
    }
    
	\endcode

	*/
#define CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH( seconds, ... ) INTERNAL_BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH( seconds, __VA_ARGS__ )





/** \def CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH(seconds, continuationFunc )

    Continues the current test section after waiting for the specified number of seconds. If the computer is
    under high load, or if the test application is suspended then the wait time is automatically increased.
    Note that this increase is just a rough heuristic - it is not guaranteed that the process will get
    the exact specified amount of processing time before the wait finishes.

    Also see \ref CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS_WITH, which waits exactly the specified time,
    without increasing it due to high load.
    
    Seconds is a floating point  number, so you can also specify non-integer amounts of
    seconds (e.g. 0.1 to wait for 100 milliseconds).

    After the delay the section is continued by calling the specified continuation function / lambda.

    This is very similar to CONTINUE_SECTION_AFTER_RUN_SECONDS, except that you can pass the code to be executed as
    a function object parameter, instead of specifying it in a code block after the CONTINUE_SECTION_AFTER_RUN_SECONDS statement.

    This can sometimes be useful if you want the continuation to be a real function, or a function with
    bounds parameters (using std::bind) or things like that.
    
    Apart from this difference, the macro works exactly like CONTINUE_SECTION_AFTER_RUN_SECONDS.

	Example:

	\code

    void continueButtonClickTest(bool* pClicked, P<Window> pWindow)
    {
        REQUIRE( *pClicked );
    }

	TEST_CASE("ButtonClick")
	{
		P<Window> pWindow = newObj<Window>();
		P<Button> pButton = newObj<Button>();

        pWindow->setContentView(pMyButton);

        bool* pClicked = new bool;
        *pClicked = false;

        // when the button is clicked then we 
		pMyButton->onClick().subscribeVoid( 
            [pClicked]()
            {
                // set pClicked to true when the button is clicked.
                *pClicked = true;
            } );

        // schedule a button click
		P<ButtonClicker> pClicker = newObj<ButtonClicker>( pMyButton );
		pClicker->scheduleButtonClick(pMyButton);

        // *pClicked will not be true yet because the imaginary ButtonClicker object
        // requires pending UI events to be handled to execute the scheduled event.

        // wait for 2.5 seconds and then continue.
		CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH( 2.5, std::bind( continueButtonClickTest, pClicked, pWindow) );        
    }
    
	\endcode

	*/
#define CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH( seconds, ... ) INTERNAL_BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS_WITH( seconds, __VA_ARGS__ )





/** \def CONTINUE_SECTION_IN_THREAD_WITH( continuationFunc )

    Similar to CONTINUE_SECTION_WHEN_IDLE_WITH, except that the continuation function is executed immediately
    from a newly created secondary thread.
    This is useful if you want to test your code from another thread (for example, to verify that it also works from
    arbitrary threads, not just the main thread).

    Apart from this difference, CONTINUE_SECTION_IN_THREAD works just like CONTINUE_SECTION_WHEN_IDLE.*/
#define CONTINUE_SECTION_IN_THREAD_WITH( ... ) INTERNAL_BDN_CONTINUE_SECTION_IN_THREAD_WITH( __VA_ARGS__ )


    
/** \def CONTINUE_SECTION_WHEN_IDLE( captures... )

    Continues the current test section after all pending UI events and scheduled work has finished
    and the event queue is empty.

    Caveat: On some platforms it may not be possible to detect a true "idle" state for the app. In that case
    the implementation is a "best effort" one that tries to make it likely that all pending work
    has finished before the test continues - see asyncCallFromMainThreadWhenIdle() for more information.
    
    A code block with the code for the continuation must follow (see example below).
    There must be a semicolon after the code block.
    
    CONTINUE_SECTION_WHEN_IDLE is mainly useful if you need pending events to be processed
    before the test continues. It is often used in tests that use user interface elements.

    The continuation code block that follows is always called from the main thread.
    There is also a similar macro called CONTINUE_SECTION_IN_THREAD which runs the continuation
    function in a new thread instead of the main thread.

    CONTINUE_SECTION_WHEN_IDLE can also be used directly in TEST_CASE blocks, not just in SECTION blocks.

    Your test section (or test case if you do not use sections) should end after the CONTINUE_SECTION_WHEN_IDLE statement
    and its code block.
    If there is additional test code afterwards then it will be executed BEFORE the continuation code
    is run. Since that is unintuitive, it should be avoided.
    
    Continuations can also be chained. I.e. continuation code block can also have a CONTINUE_SECTION_WHEN_IDLE statement
    at the end (inside the continuation code block) to add another asynchronous continuation.

    The normal test macros (like REQUIRE() ) can all be used as normal in the continuation. There
	is no difference to a synchronous test in this regard.
        
    The code block after CONTINUE_SECTION_WHEN_IDLE will actually end up being executed as a lambda function.
    The capture statement of the lambda expression are the (optional) parameters of the 
    CONTINUE_SECTION_WHEN_IDLE macro. Often one will simply specify = here to capture
    the local variables by value.


    
	Example:

	\code

	TEST_CASE("ButtonClick")
	{
		P<Window> pWindow = newObj<Window>();
		P<Button> pButton = newObj<Button>();

        pWindow->setContentView(pMyButton);

        bool* pClicked = new bool;
        *pClicked = false;

        // when the button is clicked then we 
		pMyButton->onClick().subscribeVoid( 
            [pClicked]()
            {
                // set pClicked to true when the button is clicked.
                *pClicked = true;
            } );

		// schedule a button click
		P<ButtonClicker> pClicker = newObj<ButtonClicker>( pMyButton );
		pClicker->scheduleButtonClick(pMyButton);

        // *pClicked will not be true yet because the imaginary ButtonClicker object
        // requires pending UI events to be handled to execute the scheduled event.

        // So we now need user interface events to be handled, causing the click to be
        // actually executed. So we have to schedule a continuation.
		CONTINUE_SECTION_WHEN_IDLE( pClicked, pWindow ) // we want to access pClicked in the continuation, so we use a lambda and add it to the capture list.
                                                    // pWindow is in the capture list so that the window will not be deleted and destroyed when the
                                                    // initial test function exits (before the lambda continuation is called).
                                                    // We could also use std::bind here instead of a lambda. See below for an example
        {
            REQUIRE( *pClicked );
        };

        // as an alternative we could also auto-capture all local variables with a "=" capture statement like this:
        CONTINUE_SECTION_WHEN_IDLE( = )
        {
            REQUIRE( *pClicked );
        };

    }

	\endcode
    */

#define CONTINUE_SECTION_WHEN_IDLE(...) BDN_CONTINUE_SECTION_WHEN_IDLE(__VA_ARGS__)




/** \def CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS(seconds, captures... )

    Continues the current test section after waiting for the specified number of seconds. 

    Continues the current test section after waiting for the specified number of seconds, according to the normal
    clock. Note that this macro will always wait the requested amount of time, no matter what happens on the computer.
    Also see \ref CONTINUE_SECTION_AFTER_RUN_SECONDS, which will automatically wait longer when the CPU is under high load
    or when the test application gets suspended by the operating system.

    Seconds is a floating point number, so you can also specify non-integer amounts of seconds (e.g. 0.1 to wait for 100 milliseconds).

    A code block with the code for the asynchronous continuation must follow (see example below).
    There must be a semicolon after the code block.
    
    CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS is mainly useful if you need to wait a while during the test
    and you want pending events to be processed while you wait.
    It is often used in tests that use user interface elements.

    The continuation code block that follows is always called from the main thread.

    CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS can also be used directly in TEST_CASE blocks, not just in SECTION blocks.

    Your test section (or test case if you do not use sections) should end after the CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS statement
    and its code block.
    If there is additional test code afterwards then it will be executed BEFORE the continuation code
    is run. Since that is unintuitive, it should be avoided.
    
    Continuations can also be chained. I.e. continuation code block can also have a CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS statement
    at the end (inside the continuation code block) to add another asynchronous continuation.

    The normal test macros (like REQUIRE() ) can all be used as normal in the continuation. There
	is no difference to a synchronous test in this regard.
        
    The code block after CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS will actually end up being executed as a lambda function.
    The capture statement of the lambda expression are the (optional) parameters of the 
    CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS macro. Often one will simply specify = here to capture
    the local variables by value.
    
	Example:

	\code

	TEST_CASE("ButtonClick")
	{
		P<Window> pWindow = newObj<Window>();
		P<Button> pButton = newObj<Button>();

        pWindow->setContentView(pMyButton);

        bool* pClicked = new bool;
        *pClicked = false;

        // when the button is clicked then we 
		pMyButton->onClick().subscribeVoid( 
            [pClicked]()
            {
                // set pClicked to true when the button is clicked.
                *pClicked = true;
            } );

		// schedule a button click
		P<ButtonClicker> pClicker = newObj<ButtonClicker>( pMyButton );
		pClicker->scheduleButtonClick(pMyButton);

        // *pClicked will not be true yet because the imaginary ButtonClicker object
        // requires pending UI events to be handled to execute the scheduled event.

        // wait 2.5 seconds before continuing.
		CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS( 2.5, pClicked, pWindow ) // we want to access pClicked in the continuation, so we use a lambda and add it to the capture list.
                                                    // pWindow is in the capture list so that the window will not be deleted and destroyed when the
                                                    // initial test function exits (before the lambda continuation is called).
                                                    // We could also use std::bind here instead of a lambda. See below for an example
        {
            REQUIRE( *pClicked );
        };

        // as an alternative we could also have captured ALL local variables with a "=" capture statement like this:
        CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS(2.5, = )
        {
            REQUIRE( *pClicked );
        };

    }

	\endcode
    */

#define CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS(seconds, ...) BDN_CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS(seconds, __VA_ARGS__)





/** \def CONTINUE_SECTION_AFTER_RUN_SECONDS(seconds, captures... )

    Continues the current test section after waiting for the specified number of seconds. If the computer is
    under high load, or if the test application is suspended then the wait time is automatically increased.
    Note that this increase is just a rough heuristic - it is not guaranteed that the process will get
    the exact specified amount of processing time before the wait finishes.

    Also see \ref CONTINUE_SECTION_AFTER_ABSOLUTE_SECONDS, which waits exactly the specified time,
    without increasing it due to high load.

    Seconds is a floating point number, so you can also specify non-integer amounts of seconds (e.g. 0.1 to wait for 100 milliseconds).

    A code block with the code for the asynchronous continuation must follow (see example below).
    There must be a semicolon after the code block.
    
    CONTINUE_SECTION_AFTER_RUN_SECONDS is mainly useful if you need to wait a while during the test
    and you want pending events to be processed while you wait.
    It is often used in tests that use user interface elements.

    The continuation code block that follows is always called from the main thread.

    CONTINUE_SECTION_AFTER_RUN_SECONDS can also be used directly in TEST_CASE blocks, not just in SECTION blocks.

    Your test section (or test case if you do not use sections) should end after the CONTINUE_SECTION_AFTER_RUN_SECONDS statement
    and its code block.
    If there is additional test code afterwards then it will be executed BEFORE the continuation code
    is run. Since that is unintuitive, it should be avoided.
    
    Continuations can also be chained. I.e. continuation code block can also have a CONTINUE_SECTION_AFTER_RUN_SECONDS statement
    at the end (inside the continuation code block) to add another asynchronous continuation.

    The normal test macros (like REQUIRE() ) can all be used as normal in the continuation. There
	is no difference to a synchronous test in this regard.
        
    The code block after CONTINUE_SECTION_AFTER_RUN_SECONDS will actually end up being executed as a lambda function.
    The capture statement of the lambda expression are the (optional) parameters of the 
    CONTINUE_SECTION_AFTER_RUN_SECONDS macro. Often one will simply specify = here to capture
    the local variables by value.
    
	Example:

	\code

	TEST_CASE("ButtonClick")
	{
		P<Window> pWindow = newObj<Window>();
		P<Button> pButton = newObj<Button>();

        pWindow->setContentView(pMyButton);

        bool* pClicked = new bool;
        *pClicked = false;

        // when the button is clicked then we 
		pMyButton->onClick().subscribeVoid( 
            [pClicked]()
            {
                // set pClicked to true when the button is clicked.
                *pClicked = true;
            } );

		// schedule a button click
		P<ButtonClicker> pClicker = newObj<ButtonClicker>( pMyButton );
		pClicker->scheduleButtonClick(pMyButton);

        // *pClicked will not be true yet because the imaginary ButtonClicker object
        // requires pending UI events to be handled to execute the scheduled event.

        // wait 2.5 seconds before continuing.
		CONTINUE_SECTION_AFTER_RUN_SECONDS( 2.5, pClicked, pWindow ) // we want to access pClicked in the continuation, so we use a lambda and add it to the capture list.
                                                    // pWindow is in the capture list so that the window will not be deleted and destroyed when the
                                                    // initial test function exits (before the lambda continuation is called).
                                                    // We could also use std::bind here instead of a lambda. See below for an example
        {
            REQUIRE( *pClicked );
        };

        // as an alternative we could also have captured ALL local variables with a "=" capture statement like this:
        CONTINUE_SECTION_AFTER_RUN_SECONDS(2.5, = )
        {
            REQUIRE( *pClicked );
        };

    }

	\endcode
    */

#define CONTINUE_SECTION_AFTER_RUN_SECONDS(seconds, ...) BDN_CONTINUE_SECTION_AFTER_RUN_SECONDS(seconds, __VA_ARGS__)




/** \def CONTINUE_SECTION_IN_THREAD( captures... )

    Similar to CONTINUE_SECTION_WHEN_IDLE, except that the continuation function is executed immediately from a newly created
    secondary thread.
    This is useful if you want to test your code from another thread (for example, to verify that it also works from
    arbitrary threads, not just the main thread).

    Apart from this difference, CONTINUE_SECTION_IN_THREAD works just like CONTINUE_SECTION_WHEN_IDLE.*/
#define CONTINUE_SECTION_IN_THREAD(...) BDN_CONTINUE_SECTION_IN_THREAD(__VA_ARGS__)


#define REGISTER_REPORTER( name, reporterType ) INTERNAL_BDN_REGISTER_REPORTER( name, reporterType )
#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_BDN_REGISTER_LEGACY_REPORTER( name, reporterType )

#define GENERATE( expr) INTERNAL_BDN_GENERATE( expr )

#endif

#define BDN_TRANSLATE_EXCEPTION( signature ) INTERNAL_BDN_TRANSLATE_EXCEPTION( signature )

// "BDD-style" convenience wrappers
#ifdef BDN_CONFIG_VARIADIC_MACROS
#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
#define SCENARIO_METHOD( className, ... ) INTERNAL_BDN_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#else
#define SCENARIO( name, tags ) TEST_CASE( "Scenario: " name, tags )
#define SCENARIO_METHOD( className, name, tags ) INTERNAL_BDN_TEST_CASE_METHOD( className, "Scenario: " name, tags )
#endif
#define GIVEN( desc )    SECTION( std::string("   Given: ") + desc, "" )
#define WHEN( desc )     SECTION( std::string("    When: ") + desc, "" )
#define AND_WHEN( desc ) SECTION( std::string("And when: ") + desc, "" )
#define THEN( desc )     SECTION( std::string("    Then: ") + desc, "" )
#define AND_THEN( desc ) SECTION( std::string("     And: ") + desc, "" )

using bdn::Detail::Approx;

namespace bdn
{
	/** Executes a test session (runs all tests). This can be called
		from a custom main function.
		Instead of calling this manually you can also use the macro #BDN_INIT_COMMANDLINE_TEST_APP().
		*/
	int runTestSession( int argc, char const* const argv[] );


	/** Checks if an equality comparison of the specified values
		yields the expected result. This tests both the == and the != operator
		and also switches the order of operands.

		This is most often used to test the the == and != operators of
		a class are properly implemented.

		The call is equivalent to:

		\code
		(		(a==b)==expectedResult
			&&  (b==a)==expectedResult
			&& (!(a!=b)) == expectedResult
			&& (!(b!=a)) == expectedResult )
		\endcode
		*/
	template<typename A, typename B>
	bool checkEquality(A&& a, B&& b, bool expectedResult)
	{
		return (		( std::forward<A>(a) == std::forward<B>(b) )==expectedResult
					&&  ( std::forward<B>(b) ==  std::forward<A>(a)  )==expectedResult
					&& (!( std::forward<A>(a) != std::forward<B>(b) )) == expectedResult
					&& (!( std::forward<B>(b) != std::forward<A>(a) )) == expectedResult
				);
	}

}



namespace bdn
{
namespace test
{

void _setUnhandledProblemHandler( std::function<void(IUnhandledProblem&)> func);


/** You can use this inside test applications (those that use one of Boden's default
    test app controllers) to temporarily intercept unhandled problems and redirect their handler
    to a custom function.

    The handler is redirected to the custom function when the object is constructed
    and the redirection is removed when the object is destructed.

    Example:

    \code

    {
        RedirectUnhandledProblem redirectUnhandledProblem(
            [](IUnhandledProblem& problem)
            {
                // custom handler code
                ...
            } );

        // test code that can cause an unhandled problem. Any problems that happen
        // here will be redirected to the function (and not cause the app to exit).
        ...
    }

    // the redirection has been removed here, so unhandled problems get the default
    // handling now (usually causing the test app to terminate).

    \endcode

    */
class RedirectUnhandledProblem : public Base
{
public:
    RedirectUnhandledProblem( std::function<void(IUnhandledProblem&)> func )
    {
        _setUnhandledProblemHandler(func);
    }

    ~RedirectUnhandledProblem()
    {
        _setUnhandledProblemHandler( std::function<void(IUnhandledProblem&)>() );
    }
};


}
}

#endif // _BDN_test_H_

