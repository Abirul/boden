#ifndef BDN_WINUWP_{{name}}Core_H_
#define BDN_WINUWP_{{name}}Core_H_

#include <bdn/{{name}}.h>
#include <bdn/winuwp/ChildViewCore.h>

namespace bdn
{
namespace winuwp
{

class {{name}}Core : public ChildViewCore, BDN_IMPLEMENTS I{{name}}Core
{
private:
	static ::Windows::UI::Xaml::Controls::{{nativeControlName}}^ _create{{name}}({{name}}* pOuter)
	{
        BDN_WINUWP_TO_STDEXC_BEGIN;

		return ref new ::Windows::UI::Xaml::Controls::{{nativeControlName}}();		

        BDN_WINUWP_TO_STDEXC_END;
	}

public:

	/** Used internally.*/
	ref class {{name}}CoreEventForwarder : public ViewCoreEventForwarder
	{
	internal:
		{{name}}CoreEventForwarder({{name}}Core* pParent)
			: ViewCoreEventForwarder(pParent)
		{
		}

		{{name}}Core* get{{name}}CoreIfAlive()
		{
			return dynamic_cast<{{name}}Core*>( getViewCoreIfAlive() );
		}

	public:
		void clicked(Object^ sender, ::Windows::UI::Xaml::RoutedEventArgs^ pArgs)
		{
            BDN_WINUWP_TO_PLATFORMEXC_BEGIN

			{{name}}Core* p{{name}}Core = get{{name}}CoreIfAlive();
			if(p{{name}}Core!=nullptr)
				p{{name}}Core->_clicked();			

            BDN_WINUWP_TO_PLATFORMEXC_END
		}		

	private:
		ChildViewCore* _pParentWeak;
	};


	{{name}}Core({{name}}* pOuter)
		: ChildViewCore(pOuter, _create{{name}}(pOuter), ref new {{name}}CoreEventForwarder(this) )
	{
        BDN_WINUWP_TO_STDEXC_BEGIN;

		_p{{nativeControlname}} = dynamic_cast< ::Windows::UI::Xaml::Controls::{{nativeControlName}}^ >( getFrameworkElement() );

		{{name}}CoreEventForwarder^ pEventForwarder = dynamic_cast<{{name}}CoreEventForwarder^>( getViewCoreEventForwarder() );

		_p{{nativeControlname}}->Click += ref new ::Windows::UI::Xaml::RoutedEventHandler( pEventForwarder, &{{name}}CoreEventForwarder::clicked );
		
		setPadding( pOuter->padding() );
		// Set your properties here

        BDN_WINUWP_TO_STDEXC_END;
	}


    void setPadding(const Nullable<UiMargin>& pad) override
	{
        BDN_WINUWP_TO_STDEXC_BEGIN;

		// Apply the padding to the control, so that the content is positioned accordingly.
        UiMargin uiPadding;
        if(pad.isNull())
        {
            // we should use a default padding that looks good.
            // Xaml uses zero padding as the default, so we cannot use their
            // default value. So we choose our own default that matches the
            // normal aesthetic of Windows apps.
            uiPadding = UiMargin(UiLength::sem(0.4), UiLength::sem(1) );
        }
        else
            uiPadding = pad;

		Margin padding = uiMarginToDipMargin(uiPadding);
        
        // UWP also uses DIPs => no conversion necessary

        // Note that the padding must be set on the {{name}} Content to have an effect. The {{name}}
        // class itself seems to completely ignore it.
        _contentPadding = ::Windows::UI::Xaml::Thickness(
			padding.left,
			padding.top,
			padding.right,
			padding.bottom );
        _applyContentPadding = true;

        if(_p{{nativeControlname}}->Content!=nullptr)
            ((::Windows::UI::Xaml::Controls::TextBlock^)_p{{nativeControlname}}->Content)->Padding = _contentPadding;

        
        BDN_WINUWP_TO_STDEXC_END;
	}

	// Implement your property setters here


protected:
	void _clicked()
	{
        P<View> pOuterView = getOuterViewIfStillAttached();
        if(pOuterView!=nullptr)
        {
		    ClickEvent evt(pOuterView);
		    cast<{{name}}>(pOuterView)->onClick().postNotification(evt);
        }
	}
   
	::Windows::UI::Xaml::Controls::{{nativeControlName}}^ _p{{nativeControlname}};

    ::Windows::UI::Xaml::Thickness _contentPadding;
    bool                           _applyContentPadding = false;	
};

}
}

#endif
