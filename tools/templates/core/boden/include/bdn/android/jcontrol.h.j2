#ifndef BDN_ANDROID_J{{nativeControlName}}_H_
#define BDN_ANDROID_J{{nativeControlName}}_H_

#include <bdn/android/<<ANDROID_SUPER_CLASS>>.h> // TODO: change super class include
#include <bdn/java/JString.h>

namespace bdn
{
namespace android
{


/** Accessor for Java android.widget.{{nativeControlName}} objects.*/
class J{{nativeControlName}} : public <<ANDROID_SUPER_CLASS>> // TODO: change super class
{
private:
    static bdn::java::Reference newInstance_(JContext& context)
    {
        static bdn::java::MethodId constructorId;

        return getStaticClass_().newInstance_(constructorId, context);
    }

public:
    J{{nativeControlName}}(JContext& context)
     : JTextView( newInstance_(context) )
    {
    }

    /** @param javaRef the reference to the Java object.
    *      The JObject instance will copy this reference and keep its type.
    *      So if you want the JObject instance to hold a strong reference
    *      then you need to call toStrong() on the reference first and pass the result.
    *      */
    explicit J{{nativeControlName}}(const bdn::java::Reference& javaRef)
     : JTextView(javaRef)
    {
    }

    J{{nativeControlName}}()
    {
    }


    /** Returns the JClass object for this class.
     *
     *  Note that the returned class object is not necessarily unique for the whole
     *  process.
     *  You might get different objects if this function is called from different
     *  shared libraries.
     *
     *  If you want to check for type equality then you should compare the type name
     *  (see getTypeName() )
     *  */
    static bdn::java::JClass& getStaticClass_ ()
    {
        static bdn::java::JClass cls( "android/widget/{{nativeControlName}}" );

        return cls;
    }

    

};


}
}

#endif // BDN_ANDROID_J{{nativeControlName}}_H_
